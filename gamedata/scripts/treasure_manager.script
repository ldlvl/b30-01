local rare_list = {
    novice_section = {
        "bandit_outfit",
        "stalker_outfit",
        "outfit_soldier_m1",
        "cs_light_outfit",
        "svoboda_light_outfit",

        "wpn_toz34",
        "wpn_ak74",
        "wpn_pb",
        "wpn_fort_m1",

        "grenade_rgd5",
        "grenade_f1",

        "ammo_12x76_dart",
        "ammo_5.45x39_ap",
        "ammo_9x19_pbp",
        "ammo_9x18_pmm",

        "af_medusa",
        "af_vyvert",
        "af_blood",
        "af_electra_sparkler",
        "af_rusty_thorn",
        "af_ameba_slime",
        "af_drops",
        "af_gravi",
        "af_cristal_flower",
        "af_mincer_meat",
        "af_electra_flash",
        "af_rusty_kristall",
        "af_ameba_slug",
        "af_fireball",

        "repair_itemoutfit_feik",
        "repair_item_weapon_feik",
        "medkit_army",
        "antirad",
        "conserva",
        "green_kolbasa",
        "playboy2",
        "vodka"
    },
    experienced_section = {
        "svoboda_heavy_outfit",
        "outfit_dolg_m1",
        "outfit_killer_m1",
        "bandit_veteran_outfit",
        "monolit_gaz_outfit_m1",
        "scientific_outfit",
        "svoboda_light_outfit",
        "specops_outfit",
        "dolg_gaz_outfit_m1",
        "killer_gaz_outfit_m1",

        "wpn_wincheaster1300",
        "wpn_ak47",
        "wpn_ak74pbn",
        "wpn_beretta",
        "wpn_aks47",
        "wpn_bizon",
        "wpn_fort_m1",
        "grenade_f1",

        "ammo_7.62x54_ap",
        "ammo_9x19_pbp",
        "ammo_9x39_sp5",
        "ammo_7.62x39_ap",
        "ammo_12x76_dart",
        "ammo_5.45x39_ap",

        "af_unknown_1_new",
        "af_unknown_2_new",
        "af_unknown_3_new",
        "af_unknown_4_new",
        "af_unknown_5_new",
        "af_unknown_6_new",
        "af_unknown_7_new",
        "af_unknown_8_new",
        "af_unknown_9_new",
        "af_unknown_10_new",

        "af_ameba_slug",
        "af_cristal_flower",
        "af_electra_flash",
        "af_fireball",
        "af_gravi",
        "af_mincer_meat",
        "af_rusty_kristall",
        "af_rusty_thorn",

        "playboy2",
        "flesh_leather",
        "repair_itemoutfit_feik",
        "repair_item_weapon_feik",
        "medkit_army",
        "antirad",
    },
    veteran_section = {
        "bandit_master_outfit",
        "svoboda_gaz_outfit_m1",
        "protection_outfit",
        "military_outfit",

        "wpn_aps",
        "wpn_spas12",
        "wpn_rpk74",
        "wpn_groza",
        "wpn_winchester_m1",                    -- обрез мп133
        "wpn_addon_grenade_launcher",
        "wpn_addon_grenade_launcher_m203",
        "wpn_akm",
        "wpn_eagle_m1",                         -- револьвер
        "grenade_f1",

        "ammo_vog-25",
        "ammo_m209",
        "ammo_7.62x39_ap",
        "ammo_7.62x54_7h1",
        "ammo_7.62x54_ap",
        "ammo_12x76_zhekan",
        "ammo_12x76_dart",
        "ammo_9x39_sp5",
        "ammo_9x39_ap",

        "af_electra_moonlight_new",             -- псевдоцвет
        "af_ice",                               -- мороженное
        "af_electra_sparkler_new",              -- электробенгал
        "af_flower_new",                        -- пицца
        "af_crist_new",                         -- призрачный кристалл
        "af_star_new",                          -- одуванчик
        "af_electra_flash_new",                 -- блик
        "af_medus_new",                         -- горгона
        "af_glass_new",                         -- звездочка
        "af_dummy_fire",                        -- пузырёк

        "capsule",

        "af_cristall",
        "af_night_star",
        "af_ameba_mica",
        "af_gold_fish",
        "af_rusty_sea-urchin",
        "af_soul",
        "af_electra_moonlight",
        "af_dummy_green_medusa",
        "af_dummy_green_vyvert",
        "af_dummy_green_blood",
        "af_dummy_buliz",
        "af_eye",

        "af_unknown_11_new",
        "af_unknown_12_new",
        "af_unknown_13_new",
        "af_unknown_14_new",
        "af_unknown_15_new",
        "af_unknown_16_new",
        "af_unknown_17_new",
        "af_unknown_18_new",
        "af_unknown_19_new",
        "af_unknown_20_new",
        "af_unknown_21_new",
        "af_unknown_22_new",
        "af_unknown_23_new",
        "af_unknown_24_new",
        "af_unknown_25_new",

        "playboy1",
        "suhpay",
        "antirad",
        "flesh_leather",
        "medkit_scientic",
        "amk_ballon",
    },
    master_section = {
        "svoboda_heavy_gaz_outfit_m1",
        "monolit_scientific_outfit",
        "merc_scientific_outfit",
        "freedom_scientific_outfit",
        "outfit_svoboda_m1",
        "bandit_master_outfit_m1",
        "exo_bandit_outfit",

        "wpn_addon_cobra",
        "wpn_addon_eotech",
        "wpn_groza",
        "wpn_vintorez",
        "wpn_val",
        "wpn_svu",
        --"wpn_gm94",
        "wpn_mp153_m1",                         -- обрез мп153
        --"wpn_winchester_m1",                    -- обрез мп133

        "ammo_vog-25",
        "ammo_m209",
        "ammo_7.62x54_7h14",
        --"ammo_12x76_zhekan",
        "ammo_og-7b",
        "grenade_f1",
        "ammo_9x39_ap",
        --"ammo_11.43x23_hydro",
        --"ammo_7.62x51_fmj",
        "ammo_7.62x51_ap",
        "ammo_8.6x70",
        "ammo_8.6x70_ap",

        "capsule",

        "af_cristall",
        "af_night_star",
        "af_ameba_mica",
        "af_gold_fish",
        "af_rusty_sea-urchin",
        "af_soul",
        "af_electra_moonlight",
        "af_dummy_battery",
        "af_dummy_dummy",
        "af_dummy_glassbeads",
        "af_dummy_pellicle",
        "af_dummy_spring",
        "af_dummy_simbion",
        "af_dummy_green_medusa",
        "af_dummy_green_vyvert",
        "af_dummy_green_blood",
        "af_red_dummy_spring",
        "af_red_dummy_battery",
        "af_red_dummy_pellicle",
        --"af_sul_new",                           -- дирижабль
        "af_eye",                               -- глаз
        --"af_compass",                           -- компасс
        --"af_dummy_dummy_new",                   -- изолятор
        --"af_baloon",                            -- балончик
        "af_dummy_buliz",                       -- булыжник
        "af_dummy_fire",                        -- пузырёк
        "af_flower_new",                        -- пицца

        "af_armor_1",
        "af_babka_1",
        "af_cry_1",
        "af_dik_1",
        "af_kol_1",
        "af_pudd_1",
        "af_spirit_1",

        "af_unknown_26_new",
        "af_unknown_27_new",
        "af_unknown_28_new",
        "af_unknown_29_new",
        "af_unknown_30_new",
        "af_unknown_31_new",

        "playboy1",
        "playboy2",
        "suhpay",
        "medkit_scientic",
    }
}

local treasure_manager = nil
local n_rank 

g_ini_file = ini_file( "misc\\treasure_manager.ltx" )

function parse_spawns( line )
    if line == nil then return {} end
    local t = se_respawn.parse_names( line )
    local n = table.getn( t )
    local ret_table = {}
    local k = 1
    while k <= n do
        local spawn = {}
        spawn.section = t[ k ]
        if t[ k + 1 ] ~= nil then
            local p = tonumber( t[ k + 1 ] )
            if p then
                spawn.prob = p
                k = k + 2
            else
                spawn.prob = 1
                k = k + 1
            end
        else
            spawn.prob = 1
            k = k + 1
        end
        table.insert( ret_table, spawn )
    end
    return ret_table
end

---------------------------------------------------------------------------------

class "CTreasure"

function CTreasure:__init()
    self.ini = g_ini_file 
    if not self.ini:section_exist( "list" ) then
        abort( "There is no section [list] in treasure_manager.ltx" )
    end
    local n            = self.ini:line_count( "list" )
    local id, value    = "", ""
    local r_trs_item   = ReadIni( db.stor_ltx, "stor", "r_treas_items" ) or "1"
    self.treasure_info = {}
    for i = 0, n - 1 do
        result, id, value = self.ini:r_line( "list", i, "", "" )
        self.treasure_info[ id ] = {}
        self.treasure_info[ id ].target = utils.cfg_get_number(
            self.ini, id, "target", nil, true
        )
        self.treasure_info[ id ].name = utils.cfg_get_string(
            self.ini, id, "name", nil, true, ""
        )
        self.treasure_info[ id ].description = utils.cfg_get_string(
            self.ini, id, "description" .. r_trs_item, nil, true, ""
        )
        self.treasure_info[ id ].items = parse_spawns(
            utils.cfg_get_string( self.ini, id, "items" .. r_trs_item, nil, true, "" )
        )
        local community = parse_names(
            utils.cfg_get_string( self.ini, id, "community" .. r_trs_item, nil, false, "", "stalker" )
        )
        self.treasure_info[ id ].community = {}
        for k, v in pairs( community ) do
            self.treasure_info[ id ].community[ v ] = true
        end
        if self.treasure_info[ id ].items == nil then
            abort( "cant find 'items' in %s", id )
        end
        self.treasure_info[id].condlist = xr_logic.parse_condlist(
            db.actor, "treasure_manager", "condlist",
            utils.cfg_get_string( self.ini, id, "condlist", nil, false, "", "" )
        )
        self.treasure_info[ id ].active = false
        self.treasure_info[ id ].done   = false
    end
    self.treasure_by_target = {}
    for k, v in pairs( self.treasure_info ) do
        self.treasure_by_target[ v.target ] = k 
    end
end

function CTreasure:offline_give_treasure( npc )
    local res, boxlist = amk_offline_alife.give_treasure( npc )
    if res then 
        if boxlist and table.getn( boxlist ) > 0 then
            for iter, box_story_id in pairs( boxlist ) do
                local k = self.treasure_by_target[ box_story_id ]
                if k ~= nil then 
                    self.treasure_info[ k ].active = true
                    self.treasure_info[ k ].done   = true
                end
            end
        end
        return true
    end
    return false
end

function CTreasure:use( npc, community, rang_n )
    local shron, rarets, comm
    if npc ~= nil then
        if self:offline_give_treasure( npc ) then 
            shron = 0
            return shron
        end
        comm   = npc:character_community()
        n_rank = npc:character_rank()
    else 
        n_rank = rang_n or 0
        comm   = community
    end
    local avail, tr_sum  = {}, 0
    for k, v in pairs( self.treasure_info ) do
        if
            v.done == false
            and v.active == false
            and v.community[ comm ] == true
        then
            local treasure_prob = xr_logic.pick_section_from_condlist( db.actor, npc, v.condlist )
            if treasure_prob == "" or treasure_prob == nil then treasure_prob = 5 end
            if
                tonumber( treasure_prob ) >= 0
                and v.community[ comm ]   == true
                and v.active              == false
            then
                if tonumber( treasure_prob ) == 100 then
                    shron = k
                else
                    table.insert( avail, { k = k, prob = treasure_prob } )
                    tr_sum = tr_sum + treasure_prob
                end
            end
        end
    end
    if tr_sum == 0 or dsh.get_next_random( "treasure_manager.rnd" ) < 0.75 then
        shron = 0
        return shron
    end
    local tr_w = dsh.get_next_random( "treasure_manager.rnd", tr_sum )
    for k, v in pairs( avail ) do
        tr_w = tr_w - v.prob
        if tr_w <= 0 then
            shron = v.k
            break
        end
    end
    return shron
end

function CTreasure:check()
    for k, v in pairs( self.treasure_info ) do self:give_treasure( k ) end
end

function CTreasure:give_treasure( k, from_pda )
    local v   = self.treasure_info[ k ]
    local obj = alife():story_object( v.target )
    if obj ~= nil and self.treasure_info[ k ].done ~= true then
        if not from_pda then
            sak.send_treasure( v.name )
            --local text = "%c[255,238,155,23]" .. game.translate_string( v.name ) .. "\\n" ..
            --             "%c[default]" .. game.translate_string( v.description )
            local spot = lua_random( 1, 3 )
            level.map_add_object_spot_ser(
                obj.id, "crlc_big_treasure" .. spot, "Получил наводку на схрон в этом районе."
            )
        else
            sak.send_treasure( "pda_secret" )
            level.map_add_object_spot_ser( obj.id, "crlc_big_treasure4", "" )
            if  db.actor:object( "klava" ) then
                local msg_id = "treasure" .. "_" .. tostring( vergas_lib.set_pr_from_config( "list_treasure_pda", k ) ) .."_1"
                                --"_" .. ReadIni( db.stor_ltx, "stor", "r_treas_items" )
                vergas_lib.add_record_in_klava( msg_id )
            end
        end
        -- проверка, какой тип тайника выбран
        -- если тайник не именной, то заменим содержимое
        local t_items = {}
        if self:named_treasure( self.treasure_info[ k ] ) == false then
            -- передадим уровень схрона, чтобы по нему забить наполнение
            t_items = self:give_item_list( skip_onetime_items, obj.level_name )
        else
            t_items = v.items
        end
        for kk, vv in pairs( t_items ) do
            for i = 1, vv.prob do
                if vv.section == "capsule" then
                    vv.section = sak_dialog.treasure_any_capsule()
                end
                if
                    strposx( vv.section, "af_" )
                    and not str_in_tab( vv.section, {
                        "_dummy_",
                        "_1", "_2", "_3", "_4",
                        "_dyn",
                        "_new",
                        "full_akkum",
                        "simbion",
                        "baloon"
                    } )
                then
                    vv.section = vv.section .. "_dyn" .. tostring(
                                    dsh.get_next_random( "treasure_manager.rnd", 1, 5 )
                                 ) .. "d"
                end
                local obj_sp = misc.spawn_to( vv.section, obj )
                if vv.section == "arc_art_box_basic" then
                    sak_dialog.spawn_arts_cont( obj_sp )
                elseif
                    strposx( vv.section, "wpn_" )
                    and not strposx( vv.section, "wpn_addon" )
                then
                    if dsh.get_next_random( "treasure_manager.rnd" ) > 0.5 then
                        local ammo_tbl = se_respawn.parse_names(
                            utils.cfg_get_string(
                                system_ini(), vv.section, "ammo_class", false, false, false, ""
                            )
                        )
                        if ammo_tbl ~= nil then
                            for k, v in ipairs( ammo_tbl ) do
                                if v == "ammo_ak" or strposx( v, "_merc" ) then
                                    table.remove( ammo_tbl, k )
                                end
                            end
                        end
                        if ammo_tbl ~= nil then
                            local ammo_sect = dsh.get_next_random( "treasure_manager.rnd", table.getn( ammo_tbl ) )
                            local ammo_cnt  = dsh.get_next_random( "treasure_manager.rnd", 1, 3 )
                            for j = 1, ammo_cnt do
                                misc.spawn_to( ammo_tbl[ ammo_sect ], obj )
                            end
                        end
                    end
                end
            end
        end
        self.treasure_info[ k ].active = true
        self.treasure_info[ k ].done   = true
        -- для статистики:
        xr_statistic.add_pts(
            "stalkerkills", game.translate_string( "st_pda_treas_found" ), 1, 0
        )
        sak.off_on( obj )
    else
    end
end

function CTreasure:give_item_list( skip_onetime_items, level_name )
    local shron_level = {
        {
            "l01_escape",
            "l02_garbage",
            "l03_agroprom",
            "hospital",
            "lost_village",
            "marsh",
            "k01_darkscape"
        },
        {
            "l03u_agr_underground",
            "l04_darkvalley",
            "l05_bar",
            "l06_rostok",
        },
        {
            "l08_yantar",
            "l04u_labx18",
            "l08u_brainlab",
            "l07_military",
            "aver",
            "red_forest",
            "limansk"
        }
    }
    local rank  = -1
    local tabla = {}
    -- сколько наименований предметов будет в тайнике
    local i = dsh.get_next_random( "treasure_manager.rnd", 1, 4 )
    -- определим ранг непися
    if n_rank == nil then
        n_rank = dsh.get_next_random( "treasure_manager.rnd", 1, 12 ) * 100
    end
    for k, v in pairs( shron_level ) do
        for vv = 1, #v do
            if v[ vv ] == level_name then rank = k end
        end
    end
    -- небольшой шанс того, что на уровне будет тайник уровнем выше
    if dsh.get_next_random( "treasure_manager.rnd" ) > 0.8 then
        rank = rank + 1
    end
    -- если не нашли уровень в таблице, то тайник "мастерский"
    if rank == -1 then rank = 4 end
    -- определим, из какой секции брать предметы, и какие именно
    local sect
    if rank     == 1 then sect = rare_list.novice_section
    elseif rank == 2 then sect = rare_list.experienced_section
    elseif rank == 3 then sect = rare_list.veteran_section
    else                  sect = rare_list.master_section
    end
    local items = {}
    for _, item in ipairs( sect ) do
        --if
            --( not skip_onetime_items )
            --or get_string( item, "treasure_manager.item_is", "" ) ~= "onetime"
        --then
            --if not given_onetime[ item ] then
                table.insert( items, item )
            --end
        --end
    end
    local t_used = 0
    local t_, ind_
    local j = 1
    local wpn_have, outfit_have = false, false
    while j <= i do
        local cnt     = 0
        local spawn   = {}
        t_used        = t_used + 1
        ind_          = dsh.get_next_random( "treasure_manager.rnd", t_used, table.getn( items ) )
        spawn.section = items[ ind_ ]
        -- установка кол-ва предметов в зависимости от секции
        local s   = tostring( spawn.section )
        if
               strposx( s, "ammo_"  )
            or strposx( s, "suhpay" )
            or s == "medkit_scientic"
        then 
            j = j + 1
            cnt = dsh.get_next_random( "treasure_manager.rnd", 1, 3 )   -- патроны, сухпайки, научные аптеки
        elseif strposx( s, "wpn_" ) then
            if not wpn_have then
                j = j + 1
                cnt = 1
                wpn_have = true
            end
        elseif strposx( s, "outfit" ) then
            if not outfit_have then
                j = j + 1
                cnt = 1
                outfit_have = true
            end
        elseif strposx( s, "exo" )
            or strposx( s, "capsule" )
        then
            j = j + 1
            cnt = 1                                                     -- броники, оружие
        elseif strposx( s, "af_" ) then
            j = j + 1
            cnt = 1                                                     -- артефакты
        elseif
               strposx( s, "playboy" )
            or strposx( s, "flesh_leather" )
            or s == "flask_army"
        then
            j = j + 1
            cnt = dsh.get_next_random( "treasure_manager.rnd", 1, 2 )   -- шкуры, плейбои, фляги
        else
            j = j + 1
            cnt = dsh.get_next_random( "treasure_manager.rnd", 1, 5 )   -- остальное
        end
        -- сохраняем инфу о текущем предмете
        spawn.prob = cnt
        table.insert( tabla, spawn )
        t_ = table.remove( items, ind_ )
        table.insert( items, 1, t_ )
    end
    return tabla
end

function CTreasure:treasure_empty( box, box_story_id )
    local k = self.treasure_by_target[ box_story_id ]
    if k == nil or self.treasure_info[ k ] == nil then return end
    if self.treasure_info[ k ].active ~= false then
        amk_offline_alife.empty_treasure( box:id() )
    end
    self.treasure_info[ k ].active = false
    if self:named_treasure( self.treasure_info[ k ] ) == false then
        self.treasure_info[ k ].done = false
    end
    for spot = 1, 4 do
        level.map_remove_object_spot( box:id(), "crlc_big_treasure" .. spot )
    end
end

function CTreasure:save( p )
    local tmp = BAD_OBJ_ID
    p:w_u16( tmp )
    amk_offline_alife.save( p )
    local size = 0
    for k, v in pairs( self.treasure_info ) do
        size = size + 1
    end
    p:w_u16( size )
    for k, v in pairs( self.treasure_info ) do
        p:w_u16 ( v.target )
        p:w_bool( v.active )
        p:w_bool( v.done   )
    end
end

function CTreasure:load( p )
    local t = p:r_u16()
    if t == BAD_OBJ_ID then
        amk_offline_alife.load( p )
        t = p:r_u16()
    end
    if t and t > 0 then
        for i = 1, t do
            local k = self.treasure_by_target[ p:r_u16() ]
            self.treasure_info[ k ].active = p:r_bool()
            self.treasure_info[ k ].done   = p:r_bool()
        end
    end
end

function CTreasure:named_treasure( v )
    if str_in_tab( v.name, {
            "val_secret_krysyk_name",
            "mar_secret_kirpich",
            "val_secret_oreh",
            "agr_secret_krysyk_name",
            "mil_secret_borov_name",
            "mil_secret_kruglov_name",
            "yan_secret_kruglov_name",
            "aver_secret_luber_ammunition_name"
        })
    then
        return true
    else
        return false
    end     
end

function get_treasure_manager()
    if treasure_manager == nil then treasure_manager = CTreasure() end
    return treasure_manager
end

function take_item_from_box( box, box_story_id )
    get_treasure_manager():treasure_empty( box, box_story_id )
end

function save( p )
    get_treasure_manager():save( p )
end

function load( p )
    get_treasure_manager():load( p )
end

function clear_treasure_manager()
    treasure_manager = nil
end

function CTreasure:dialog( npc )
    local avail = {}
    local tr_sum = 0
    for k, v in pairs( self.treasure_info ) do
        if
            v.done == false
            and v.active == false
            and v.community[ npc:character_community() ] == true
        then
            local treasure_prob = xr_logic.pick_section_from_condlist(
                db.actor, npc, v.condlist
            )
            if treasure_prob == "" or treasure_prob == nil then
                treasure_prob = 0
            end
            if
                tonumber( treasure_prob ) >= 0
                and v.community[ npc:character_community() ] == true
                and v.active == false
            then
                if tonumber( treasure_prob ) == 100 then
                    self:give_treasure( k )
                else
                    table.insert( avail, { k = k, prob = treasure_prob } )
                    tr_sum = tr_sum + treasure_prob
                end
            end
        end
    end
    if tr_sum == 0 then return end
    local tr_w = dsh.get_next_random( "treasure_manager.rnd", tr_sum )
    for k, v in pairs( avail ) do
        tr_w = tr_w - v.prob
        if tr_w <= 0 then
            self:give_treasure( v.k )
            WriteIni( db.stor_ltx, "stor", "npc_" .. npc:id(), v.k )
            break
        end
    end
end
