--[[
File:  amk_mod .script
copyright © AMK TEAM 2007-2008
--]]

in_hide       = false
sync_done     = false
last_wconf    = ""
pda_npc_logic = ""
zombied       = {}

local nrg, med, cnt, gv, lv, w, bt, sMapNow, idMapNow
local sound_obj_right, sound_obj_left, snd_volume, snd_obj_eq, dynlasthour
local tmp_intro = false

local amk_used = {
    [ "energy_drink"        ] = "sleep_manager.test_for_need_sleep_nrg()",
    [ "vodka"               ] = "sleep_manager.test_for_need_sleep_vodka()",
    [ "treasure_item"       ] = "sleep_manager.test_for_need_sleep_tr_item()",
    [ "banka"               ] = "sak.empty_banka_fill()",
    [ "kanistra"            ] = "sak.kanistra_fill()",
    [ "banka_full"          ] = "sak.banka_full_use()",
    [ "drag_cat_eyes"       ] = "sak.add_cat_eyes()",
    [ "batt_torch"          ] = "sak.new_batt_torch()",
    [ "sak_resiver_yantar"  ] = "sak.add_skaner_1_saharoff()",
    [ "sak_resiver2_yantar" ] = "sak.add_skaner_2_saharoff()",
    [ "scanner_artefact"    ] = "sak.add_scanner_artefact()",
    [ "arc_art_box_1basic"  ] = "amk_mod.cont_used()",
    [ "arc_art_box_basic"   ] = "amk_mod.cont_used()",
    [ "arc_art_box_8basic"  ] = "amk_mod.cont_used()"
}

local weather_types = {
    marsh                 = 0,
    aver                  = 2,
    generators            = 2,
    hospital              = 0,
    limansk               = 4,
    lost_village          = 4,
    red_forest            = 5,
    av_peshera            = 1,
    labx8                 = 1,
    labx10                = 1,
    warlab                = 1,
    l01_escape            = 0,
    l02_garbage           = 0,
    l03_agroprom          = 0,
    l03u_agr_underground  = 1,
    l04_darkvalley        = 4,
    k01_darkscape         = 4,
    l04u_labx18           = 1,
    l05_bar               = 0,
    l06_rostok            = 4,
    l07_military          = 4,
    l08_yantar            = 2,
    l08u_brainlab         = 1,
    l10_radar             = 5,
    l10u_bunker           = 1,
    deadcity              = 4,
    l11_pripyat           = 4,
    l12_stancia_new       = 4,
    l12_stancia_2_new     = 4,
    l12u_control_monolith = 1,
    l12u_sarcofag         = 1
}

function dbg_set_w_fx( wconf, flag )
    --wprintf("[~T]. #DBG: set_weather_fx ~C0A %s~C07", wconf)
    level.set_weather_fx( wconf, flag )
end

function dbg_set_w( wconf, flag )
    if wconf == last_wconf then return end
    --wprintf("[~T]. #DBG: set_weather ~C0A %s~C07, last =~C0A %s~C07", wconf or 'nil', last_wconf or 'nil')
    last_wconf = wconf
    level.set_weather( wconf, flag )
end

function spawn_star( actor, npc, p1, p2 )
    local points = {
        { position = { x = -3.28420424460, y = -17.6270339965, z = -154.931091308 }, gv = 108, lv = 272952 },
        { position = { x = 167.5906524658, y = 5.316465568543, z = 93.90438079834 }, gv = 155, lv = 470751 },
        { position = { x = -25.2906379699, y = 1.958913302422, z = 99.12718200684 }, gv = 86,  lv = 252031 }
    }
    local b   = lua_random( #points )
    local a   = points[ b ]
    local obj = misc.spawn_obj(
        "arc_art_box_1basic",
        vector():set( a.position.x, a.position.y, a.position.z )
    )
    local pk         = get_netpk( obj, 1 )
    local data       = pk:get()
    data.custom_data = "amk_af_night_star_29"
    data.mass        = 20
    pk:set( data )
    nlc_vars.kontainer = obj.id
    local m_where
    if news_main then
        m_where = news_main.get_point_description(
            "l01_escape", vector():set( a.position.x, a.position.y, a.position.z )
        )
    else
        m_where = "Здесь, на Кордоне"
    end
    -- db.actor:give_talk_message(
    --     " скорее всего поискать стоит. Где-то там он, точно говорю.\\nПомнишь, как контейнер-то выглядит? Вот так:",
    --     "ui\\ui_iconstotal", Frect():set( 0, 0, 10, 10 ), "simple_answer_item"
    -- )
    db.actor:give_talk_message(
        "Помнишь, как контейнер-то выглядит? Вот так:",
        "ui\\ui_iconstotal", Frect():set( 0, 0, 10, 10 ), "simple_answer_item"
    )
    db.actor:give_talk_message(
        "", "ui\\ui_icon_equipment_1", Frect():set( 0, 0, 150, 100 ), "iconed_item"
    )
    db.actor:give_info_portion( "amk_af_night_star_" .. b )
end

function on_game_start() dbg_set_w( "indoor", true ) end

function first_run()
    if amk_vars.x_first_run == nil then
        timers.start_timer( "show_news", 0, 0, 8, "amk_mod.show_news()" )
        sak.add_new_lcitem()
        amk_anoms.pre_blow_off()
        amk_anoms.after_blow_on()
        spawn_military_btr()
        spawn_fuel()
        tmp_intro = true
        amk_vars.x_first_run = false
    end
end

function update_spots( lname, sname )
    local obj1, obj2
    ----------------------------------------------------------------------
    if
           ( lname == "l01_escape"    and sname == "k01_darkscape" )
        or ( lname == "k01_darkscape" and sname== "l01_escape"     )
        and not has_alife_info( "actor_zoneguard_info" )
    then
        sak.add_new_esc_dar_112()
    end
    ----------------------------------------------------------------------
    if lname == "k01_darkscape" and sname == "l04_darkvalley" then
        sak.add_new_dsc_199()
    end
    ----------------------------------------------------------------------
    obj1 = g_sim:story_object( story_ids.hos_exit_to_esc_157 )
    obj2 = g_sim:story_object( story_ids.esc_exit_to_hos_158 )
    if obj1 and obj2 and sname == "l01_escape" and lname == "hospital" then
        level.map_add_object_spot_ser( obj1.id, "level_changer_self", "to_escape" )
        level.map_add_object_spot_ser( obj2.id, "level_changer_self", "to_hospital" )
    end
    ----------------------------------------------------------------------
    obj1 = g_sim:story_object( story_ids.dsc_exit_to_hospital_255 )
    obj2 = g_sim:story_object( story_ids.hos_lev_chang_door )
    if
        ( obj1 or obj2 )
        and (
               ( sname == "k01_darkscape" and lname == "hospital" )
            or ( lname == "k01_darkscape" and sname == "hospital" )
        )
    then
        if obj1 then
            level.map_add_object_spot_ser( obj1.id, "level_changer_self", "to_hospital" )
        end
        if obj2 then
            level.map_add_object_spot_ser( obj2.id, "level_changer_self", "to_darkscape" )
        end
    end
    ----------------------------------------------------------------------
    obj1 = g_sim:story_object( story_ids.exit_to_for )
    obj2 = g_sim:story_object( story_ids.gar_exit_to_hospital_177 )
    if
        ( obj1 and obj2 )
        and (
               ( sname == "hospital" and lname == "l02_garbage" )
            or ( sname == "l02_garbage" and lname == "hospital" )
        )
    then
        if obj1 then
            level.map_add_object_spot_ser( obj1.id, "level_changer_self", "to_garbage" )
        end
        if obj2 then
            level.map_add_object_spot_ser( obj2.id, "level_changer_self", "to_hospital" )
        end
    end
    ----------------------------------------------------------------------
    obj1 = g_sim:story_object( story_ids.lim_exit_to_red_forest_155 )
    obj2 = g_sim:story_object( story_ids.red_level_changer_to_limansk )
    if
        obj1 and obj2
        and (
               ( sname == "red_forest" and lname == "limansk" )
            or ( sname == "limansk" and lname == "red_forest" )
        )
    then
        level.map_add_object_spot_ser( obj1.id, "level_changer_self", "to_red_forest" )
        level.map_add_object_spot_ser( obj2.id, "level_changer_self", "to_limansk" )
    end
    ----------------------------------------------------------------------
    obj1 = g_sim:story_object( story_ids.ros_exit_to_red_forest_104 )
    obj2 = g_sim:story_object( story_ids.red_level_changer_to_rostok )
    if
        obj2
        and (
               ( sname == "red_forest" and lname == "l06_rostok" )
            or ( sname == "l06_rostok" and lname == "red_forest" )
        )
    then
        if not obj1 then sak.add_new_ros_red_104() end
        level.map_add_object_spot_ser( obj2.id, "level_changer_self", "to_rostok" )
    end
    ----------------------------------------------------------------------
    obj1 = g_sim:story_object( story_ids.deadcity_exit_to_generators_194 )
    obj2 = g_sim:story_object( story_ids.generators_level_changer )
    if
        obj1 and obj2
        and (
               ( sname == "generators" and lname == "deadcity" )
            or ( sname == "deadcity" and lname == "generators" )
        )
    then
        level.map_add_object_spot_ser( obj1.id, "level_changer_self", "to_generators" )
        level.map_add_object_spot_ser( obj2.id, "level_changer_self", "to_deadcity" )
    end
    ----------------------------------------------------------------------
    obj1 = g_sim:story_object( story_ids.deadcity_exit_to_prip_193 )
    obj2 = g_sim:story_object( story_ids.prip_exit_to_deadcity_195 )
    if
        obj1 and obj2
        and (
               ( sname == "l11_pripyat" and lname == "deadcity" )
            or ( sname == "deadcity" and lname == "l11_pripyat" )
        )
    then
        level.map_add_object_spot_ser( obj1.id, "level_changer_self", "to_pripyat" )
        level.map_add_object_spot_ser( obj2.id, "level_changer_self", "to_deadcity" )
    end
    ----------------------------------------------------------------------
    obj1 = g_sim:story_object( story_ids.exit_to_pripyat_01 )
    obj2 = g_sim:story_object( story_ids.exit_prip_to_radar_01 )
    if
        obj1 and obj2
        and (
               ( sname == "l11_pripyat" and lname == "l10_radar" )
            or ( sname == "l10_radar" and lname == "l11_pripyat" )
        )
    then
        level.map_add_object_spot_ser( obj1.id, "level_changer_self", "to_pripyat" )
        level.map_add_object_spot_ser( obj2.id, "level_changer_self", "to_radar" )
    end
    ----------------------------------------------------------------------
    obj1 = g_sim:story_object( story_ids.aver_level_changer_to_av_peshera )
    if
        obj1
        and (
               ( sname == "aver" and lname == "av_peshera" )
            or ( sname == "av_peshera" and lname == "aver" )
        )
    then
        level.map_add_object_spot_ser( obj1.id, "level_changer_self", "to_av_peshera" )
    end
    ----------------------------------------------------------------------
    obj1 = g_sim:story_object( story_ids.gen_exit_to_lim_190 )
    if obj1 and ( sname == "generators" and lname == "limansk") then
        level.map_add_object_spot_ser( obj1.id, "level_changer_self", "to_limansk" )
        sak.add_new_lim_gen_165()
    end
    ----------------------------------------------------------------------
    obj1 = g_sim:story_object( story_ids.gen_exit_to_mil_191 )
    if obj1 and ( sname == "generators" and lname == "l07_military" ) then
        level.map_add_object_spot_ser( obj1.id, "level_changer_self", "to_military" )
        sak.add_new_mil_gen_154()
    end
    ----------------------------------------------------------------------
    obj1 = g_sim:story_object( story_ids.gen_exit_to_radar_189 )
    if obj1 and ( sname == "generators" and lname == "l10_radar" ) then
        level.map_add_object_spot_ser( obj1.id, "level_changer_self", "to_radar" )
        sak.add_new_yantar_108()
    end
    ----------------------------------------------------------------------
    obj1 = g_sim:story_object(story_ids.red_exit_to_av_pesh_188)
    if
        obj1
        and (
               ( sname == "red_forest" and lname == "av_peshera" )
            or ( sname == "av_peshera" and lname == "red_forest" )
        )
    then
        level.map_add_object_spot_ser( obj1.id, "level_changer_self", "to_av_peshera" )
    end
    ----------------------------------------------------------------------
    obj1 = g_sim:story_object( story_ids.red_level_changer_to_yantar )
    obj2 = g_sim:story_object( story_ids.yan_exit_to_red_forest_106 )
    if obj1 and ( sname == "red_forest" and lname == "l08_yantar" ) and obj2 == nil then
        level.map_add_object_spot_ser( obj1.id, "level_changer_self", "to_yantar" )
        sak.add_new_radar_106()
    end
    ----------------------------------------------------------------------
    obj1 = g_sim:story_object( story_ids.aver_level_changer_to_garbage_135 )
    obj2 = g_sim:story_object( story_ids.gar_exit_to_aver_151 )
    if obj1 and ( sname == "aver" and lname == "l02_garbage" ) and obj2 == nil then
        level.map_add_object_spot_ser( obj1.id, "level_changer_self", "to_garbage" )
        sak.add_new_gar_aver_151()
    end
    ----------------------------------------------------------------------
    obj1 = g_sim:story_object( story_ids.aver_level_changer_to_darkvalley )
    obj2 = g_sim:story_object( story_ids.val_exit_to_aver_110 )
    if obj1 and ( sname == "aver" and lname == "l04_darkvalley" ) and obj2 == nil then
        level.map_add_object_spot_ser( obj1.id, "level_changer_self", "to_darkvalley" )
        sak.add_new_mil_110()
    end
end

function check_spawn()
    wprintf( '~CF0[~T/~U/~B]. #PERF: amk_mod.check_spawn begin~C07' )
    bt = blowout_type()
    amk_anoms.init()
    wprintf( '~CF0[~T/~U/~B]. #PERF: spawn_unspawned_respawners() ~C07')
    spawn_unspawned_respawners()
    news_main.init()
    amk_offline_alife.init()
    timers.tTimers = {}
    local obj1, obj2
    wprintf( '~CF0[~T/~U/~B]. #PERF: updating LC~C07' )
    local lc_list = {
        info_way100a   = 9100,
        info_way176a   = 9176,
        info_way101a   = 9101,
        info_way182a   = 9182,
        info_way102a   = 9102,
        info_way103a   = 9103,
        info_way104a   = 9104,
        --info_way172a = 9172,
        info_way105a   = 9105,
        info_way174a   = 9174,
        info_way106a   = 9106,
        --info_way173a = 9173,
        info_way107a   = 9107,
        info_way108a   = 9108,
        --info_way189a = 9189,
        info_way109a   = 9109,
        info_way110a   = 9110,
        --info_way136a = 9136,
        info_way111a   = 9111,
        info_way137a   = 9137,
        info_way116a   = 9116,
        info_way117a   = 9117,
        info_way151a   = 9151,
        --info_way135a = 9135,
        --info_way130a = 9130,
        --info_way112a = 1008,
        info_way113a   = 592,
        info_way114a   = 594, 
        info_way154a   = 9154,
        --info_way191a = 9191,
        info_way156a   = 9156,
        info_way165a   = 9165,
        --info_way190a = 9190,
        info_way179a   = 9179,
        info_way178a   = 9178,
        info_way181b   = 9181,
        info_way183a   = 9183,
        info_way180a   = 9180,
        info_way166a   = 9166,
        info_way184a   = 9184,
        info_way185a   = 9185,
        val_raid_start = 9199
    }
    for info, sid in pairs( lc_list ) do
        -- wprintf(" out_new_lc~C0D %4d~C0B =~C0A '%s'~C07", sid, info)
        sak.out_new_lc( sid, info )
    end
    local sid  = 593
    local objt = g_sim:story_object( sid )
    if not objt then
        wprintf( "~C0C #ERROR: level changer not exists~C0D %d~C0C, trying respawn~C07", sid )
        misc.spawn_by_story_id( sid )
    end
    local lname = level.name()
    local sname = amk_vars.level_on_save or ""
    wprintf( '~CF0[~T/~U/~B]. #PERF: updating npc tables ~C07' )
    amk_offline_alife.update_npc_tables()
    if lname ~= sname then
        wprintf( '~CF0[~T/~U/~B]. #PERF: updating map spots~C0A %s / %s~C07 ~C07', lname, sname )
        LuaSafeCall( 'amk_mod.update_spots', '#func', lname, sname )
    end
    obj = g_sim:story_object( story_ids.aes_exit_to_pripyat )
    if obj then
        level.map_add_object_spot_ser( obj.id, "level_changer_self", "to_pripyat" )
    end
    wprintf( '~CF0[~T/~U/~B]. #PERF: updating weahter ~C07' )
    if     weather_types[ lname ] == 0 then
        w = amk_vars.dynweather or level.get_weather()
    elseif weather_types[ lname ] == 1 then
        w = "indoor"
    elseif weather_types[ lname ] == 2 then
        w = amk_vars.dynweather_no_far or level.get_weather()
    elseif weather_types[ lname ] == 3 then
        w = amk_vars.dynweather_mist or level.get_weather()
    elseif weather_types[ lname ] == 4 then
        w = amk_vars.dynweather_depressive or level.get_weather()
    elseif weather_types[ lname ] == 5 then
        w = amk_vars.dynweather_storm or level.get_weather()
    else
        w = level.get_weather()
    end
    schedule.add("r_sun", "amk_mod.restore_sun()", 50 )
    schedule.dump()
    if
            ( amk_vars.blowout or 0 ) > 0
        and ( amk_vars.blowout or 0 ) < 4
    then
        level.add_cam_effector( "camera_effects\\earthquake.anm", 2002, true, "" )
        if bt < 1 then
            dbg_set_w( "amk_for_blow_depressive", true )
            level.add_pp_effector( "vibros.ppe", 2001, true )
            blowout_psy_sound( "start" )
        end
    end
    sak.get_command( "unbind contacts" )
    sak.get_command( "cl_cod_pickup_mode off" )
    wprintf( '~CF0[~T/~U/~B]. #PERF: amk_mod.check_spawn end~C07' )
end

function restore_sun()
    --ODS( sprintf("[~T]. #DBG: restore_sun") )
    timers.initialize_timers()
    if w == nil then abort( " last weather == nil" ) end
    local lname = level.name()
    local sname = amk_vars.level_on_save or ""
    --wprintf("[~T]. #DBG: weather %s name, sname=%s, w = %s", lname, sname, w)
    if ( amk_vars.blowout or 0 ) == 0 then
        if lname ~= sname then
            local last_dynw = amk_vars.last_dynw or "pasmurno"
            local dynw      = amk_vars.dynw or "pasmurno"
            local hour      = level.get_time_hours()
            if     weather_types[ lname ] == 0 then
                dbg_set_w( "amk_" .. last_dynw .. "_" .. dynw .. "_"            .. hour, true )
            elseif weather_types[ lname ] == 2 then
                dbg_set_w( "amk_" .. last_dynw .. "_" .. dynw .. "_no_far_"     .. hour, true )
            elseif weather_types[lname]==3 then
                dbg_set_w( "amk_" .. last_dynw .. "_" .. dynw .. "_mist_"       .. hour, true )
            elseif weather_types[lname]==4 then
                dbg_set_w( "amk_" .. last_dynw .. "_" .. dynw .. "_depressive_" .. hour, true )
            elseif weather_types[lname]==5 then
                dbg_set_w( "amk_" .. last_dynw .. "_" .. dynw .. "_storm_"      .. hour, true )
            else
                dbg_set_w( w, true )
            end
        else
            dbg_set_w( w, true )
        end
    else
        wprintf( " blowout ~= 0 so no weather set " )
    end
    if ( amk_vars.blow_started or 0 ) == 0 then
        start_blow_timer()
        amk_vars.blow_started = 1
    end
    if tmp_intro then tmp_intro = false end
    if db.actor then
        sak_dialog.start_time( "start_on_load_time" )
        sak.detectors_fake( false )
        vergas_art.spawn_art()
    end
    idMapNow                = g_sim:level_id()
    sMapNow                 = ( idMapNow and g_sim:level_name( idMapNow ) ) or ""
    db.idMapSav             = amk_vars.map_sav or 0
    db.sMapSav              = ( db.idMapSav ~= 0 and g_sim:level_name( db.idMapSav ) ) or ""
    db.idMapNow, db.sMapNow = idMapNow, sMapNow
    amk_vars.map_sav        = idMapNow
    amk_vars.level_on_save  = lname
    sak.start_progress()
end

function freeplay()
    amk_vars.freeplay = 1
    local obj = g_sim:story_object( story_ids.aes_exit_to_pripyat )
    if not obj then misc.spawn_by_name( 'exit_to_pripyat_from_st1' ) end
    for a = 1, 5 do
        if amk_anoms then amk_anoms.after_blow_on() end
    end
end

function show_news()
    timers.start_timer( "show_news_main", 49, "news_main.on_news()" )
    local min_rand = lua_random( 27, 53 )
    timers.start_timer( "show_news", 0, 0, min_rand, "amk_mod.show_news()" )
    local ln = level.name()
    if
        news_main.isIsolatedLevel( ln ) == true
        or db.actor:has_info( "pda_is_broken" )
    then
        return
    end
    if lua_random() > 0.5 then
        if lua_random() > 0.875 then
            if lua_random() > 0.5 then
                local dolg_news = amk_dolg.get_strings()
                db.actor:give_game_news(
                    dolg_news, "ui\\ui_iconsTotal", Frect():set( 498, 141, 83, 47 ), 4000, 15000
                )
            else
                local freedom_news = amk_freedom.get_strings()
                db.actor:give_game_news(
                    freedom_news, "ui\\ui_iconsTotal", Frect():set( 498, 94, 83, 47 ), 3000, 15000
                )
            end
        end
    else
        if lua_random() > 0.5 then
            local info, who, uniq, who2, uniq2, info2 = amk_uniq_news_lists.get_strings()
            if
                    ( info  == "" or not has_alife_info( info ) )
                and ( info2 == "" or has_alife_info( info2 ) )
            then
                local name, sname = amk_names_lists.get_strings()
                if who ~= "" then
                    amk.send_tip( uniq, who, nil, 15, "uniq", "news", "gray" )
                else
                    amk.send_tip( uniq, name .. " " .. sname, nil, 15, "uniq", "news", "gray" )
                end
                if uniq2 ~= "" then
                    name, sname = amk_names_lists.get_strings()
                    if who2 ~= "" then
                        amk.send_tip( uniq2, who2, 10, 15, "uniq", "news", "gray" )
                    else
                        amk.send_tip( uniq2, name .. " " .. sname, 7, 15, "uniq", "news", "gray" )
                    end
                end
            end
        end
    end
end

function test_for_need_sleep() end -- заглушка от сбоев из-за хранимых таймеров

function used_item( obj )
    local sect = obj:section()
    if amk_used[ sect ] then
        local txt = amk_used[ sect ]
        loadstring( txt )()
    end
end

function cont_used() arc_containers.used_cont = true end

function test_for_need_sleep_matras( oid )
    --Vergas sleeping_bag---------------ON--------------------
    local flag     = false
    local flag_bag = false
    if oid:section() == "sleeping_bag" then
        flag = true
    elseif type( oid ) == 'number' and g_sim:object( oid ) == nil then
        flag = true
    end
    if not flag then return end
    --Vergas sleeping_bag---------------OFF-------------------
    local enemy = false
    local self  = level.main_input_receiver()
    if self then self:GetHolder():start_stop_menu( self, true ) end
    -- одетый рюкзак мешает залезть в мешок
    local act = db.actor
    local equ = false
    if get_shadow_inv():update_storage() then equ = true end
    for a, i in pairs( db.storage ) do
        local objg = client_obj( a )
        if objg then
            if (
                objg
                and (
                    (
                        IsStalker( objg )
                        and amk.get_npc_relation( objg,db.actor ) == "enemy"
                        and objg:alive()
                    )
                    or IsMonster( objg )
                    and not string.find( objg:name(), "^rat_" ) )
                    and objg:position():distance_to( db.actor:position() ) < 30
                    and objg:alive()
                )
            then
                enemy = true
                break
            end
        end
    end
    if enemy == true then
        flag_bag = true
        amk.send_tip( game.translate_string( "not_need_sleep_enemy" ), nil, nil, 5 )
    else
        if
                ( amk_vars.blowout or 0 ) > 0
            and ( amk_vars.blowout or 0 ) < 5
        then
            flag_bag = true
            amk.send_tip( game.translate_string( "blowout_not_sleep" ), nil, nil, 5 )
        elseif ( equ ) then
            flag_bag = true
            wprintf( "[~T]. #SLEEP_REJECT: equipment thwarted" )
            amk.send_tip( game.translate_string( "cant_sleep_equip" ), nil, nil, 5 )
        elseif ( nlc_vars.block_sleep_menu or 0 ) == 0 then
            if sleep_manager.get_sleepiness( 108 ) > 10 then
                if oid:section() == "sleeping_bag" then
                    vergas_lib.s_play( [[device\sleeping_bag\sleep_bag_down]] )
                    sleep_manager.sleep_in_sleeping_bag = 2 -- в спальнике голод во сне растёт в 2 раза медленнее
                end
                used_items.sleep_management()
            else --Меченный не хочет спать
                flag_bag = true
                wprintf(
                    "[~T]. #SLEEP_REJECT: actor sleepiness =~C0D %.3f~C07",
                    sleep_manager.get_sleepiness( 108 )
                )
                amk.send_tip( game.translate_string( "not_need_sleep" ), nil, nil, 5 )
            end
        else     --действует энергетик
            flag_bag = true
            amk.send_tip( game.translate_string( "not_need_sleep_nrg" ), nil, nil, 5 )
        end
    end
    if flag_bag then sleeping_bag.no_sleep() end
    if oid:section() ~= "sleeping_bag" then
        amk.spawn_item_in_inv( "matras" )
    end
end

function esc_sleep_matras()
    if ( amk_vars.blowout or 0 ) > 0 and ( amk_vars.blowout or 0 ) < 5 then
        amk.send_tip( game.translate_string( "blowout_not_sleep" ), nil, nil, 5 )
    elseif ( nlc_vars.block_sleep_menu or 0 ) == 0 then
        if sleep_manager.get_sleepiness( 108 ) > 10 then --было >10
            used_items.sleep_management()
        else
            amk.send_tip( game.translate_string( "not_need_sleep" ), nil, nil, 5 )
        end
    elseif bt > 0 then
        amk.send_tip( game.translate_string( "not_need_sleep_undegrourd" ), nil, nil, 5 )
    else
        amk.send_tip( game.translate_string( "not_need_sleep_nrg"), nil, nil, 5 )
    end
end

function test_for_need_sleep_tr_item()
    sak_box_move.create_treasurebox()
    local self = level.main_input_receiver()
    if self then
        self:GetHolder():start_stop_menu( self, true )
    end
end

--'*******************************************************
--'****************      RADAR_FIX      ******************
--'*******************************************************

local time_radar = time_global()

function check_radar_off()
    if level.name() == "l10_radar" then
        if
                not has_alife_info( "bar_deactivate_radar_done" )
            and not has_alife_info( "time_morning" )  -- с 
        then
            local pos = db.actor:position()
            if pos.z > 65 and pos.x > 350 and pos.x < 410 then
                local time_current = time_global()
                local time_delta   = time_current - time_radar
                if time_delta >= 1100 then
                    local h     = hit()
                    h.draftsman = db.actor
                    h:bone( "eyelid_1" )
                    h.type      = hit.explosion
                    h.power     = 0.01 * ( pos.z - 65 )
                    h.impulse   = 0.0
                    db.actor:hit( h )
                    h:bone( "bip01_spine" )
                    h.type      = hit.telepatic
                    h.power     = 0.01 * ( pos.z - 65 )
                    db.actor:hit( h )
                    time_radar  = time_current
                end
            end
        end
    end
end

local afs = {
    "af_medusa",
    "af_blood",
    "af_drops",
    "af_vyvert",
    "af_soul",
    "af_fireball",
    "af_electra_",
    "af_electra_moonlight",
    "af_rusty_",
    "af_rusty_sea-urchin",
    "af_cristal_flower",
    "af_night_star",
    "af_gravi",
    "af_mincer_meat",
    "af_ameba_",
    "af_gold_fish",
    "af_cristall",
    "af_dummy_",
    "af_red_dummy_",
    "af_kol_",
    "af_armor_",
    "af_pudd_",
    "af_dik_",
    "af_babka_",
    "af_spirit_",
    "af_unknown_",
    "af_cry_",
    "af_dummy_kolobok",
    "kolbasa",
    "conserva",
    "vodka",
    "bandage",
    "mutant_",
    "bread",
    "energy_drink"
}

local arts_added = {}

function check_for_af_drop( obj )
    if obj and obj:id() then
        schedule.add(
            "check_af_drop" .. obj:id(),
            "amk_mod.check_af_drop("..obj:id()..")", 200, true
        )
    end
end

function good_source( af_sect, source )
    if nil == strposx( source, "_dyn" ) then
        af_sect = base_art( af_sect )
    end
    wprintf( " check ~C0F %s~C07 in ~C0E %s~C07", af_sect, source )
    return strposx( af_sect, source ) or false
end


function enough_arts( source )
    local t = SplitStr( source, ',' )
    for i, sc in ipairs( t ) do
        for n, ss in ipairs( arts_added ) do
            if not good_source( ss, sc ) then
                wprintf( "[~T]. #DBG: для варки не хватает~C0F %s~C07", sc )
                return false
            end
        end
    end
    return true
end

function check_af_drop( af_id ) -- варка артефактов?
    if not af_id then
        wprintf(
            "[~T].~C0C #ERROR: invalid param specified for check_af_drop.\n~C0A %s~C07",
            lua_traceback( ' ' )
        )
        return
    end
    local obj = client_obj( misc.get_object_id( af_id ) )
    if obj == nil or obj:parent() ~= nil then return end
    local section = obj:section()
    if
        str_in_tab( section, afs )
        and not strposx( section, "_capsule" )
    then
        local id, pos, radius, dist = amk_anoms.get_nearest_anomaly( obj )
        local u_tbl = xray_vars.load_table( nlc_vars, "used_anomz", {} )
        if u_tbl[ id ] then
            wprintf( "[amk_mod.script]: anomaly # " .. id .. " is depleted, sorry. Try other anomaly. Sincerely yours, THE MONOLITH." )
            return end -- чтобы не варилось в аномалии больше 1 раза
        if id and radius - dist > 1 then
            local anom_sect = client_obj( id ):section()
            check_af_transform( obj, id, anom_sect )
        end
        return
    end
end

function af_flash( af )
    level.add_pp_effector( "teleport.ppe", 1524, false )
    amk.remove_item( af )
end

function af_start_transform( v1, v2, af_from, af_target )
    local rnd = lua_random( 1, 100 )
    if not system_ini():section_exist( af_target ) then
        wprintf( "[~T].~C0C #ERROR:~C07 artefact section not exist~C0A %s~C07", af_target )
        return af_from
    end
    if rnd > v1 then
        if rnd > v2 + v1 then
            return af_from
        else
            return "af_dummy_buliz"
        end
    else
        return af_target
    end
end

function split_pair( s, delim )
    local t = SplitStr( s, delim )
    return ( t[ 1 ] or '01' ), ( t[ 2 ] or '22' )
end

local add_timer = false

function base_art( af_sect )
    return af_sect:gsub( '_dyn[1-4]d', '' ) -- base section
end

function check_reciepts( list )
    local t = SplitStr( list, "," )
    for i, info in ipairs( t ) do
        if db.actor:has_info( info ) then
            return true
        else
            -- wprintf("~C0C            not has info ~C0A %s~C07", info)
        end
    end
    return false
end

function check_af_transform( af, anom_id, anom_sect )
    local af_sect = af:section()
    local pos     = af:position()
    gv = client_obj( anom_id ):game_vertex_id()
    lv = client_obj( anom_id ):level_vertex_id()
    if gv == BAD_OBJ_ID then gv = af:game_vertex_id() end
    if gv == BAD_OBJ_ID then gv = db.actor:game_vertex_id() end
    if gv == BAD_OBJ_ID then return end
    local tt = mike.af_transform( af, anom_sect )
    if tt then return tt end
    local actor = db.actor
    local fs    = getFS()
    local fname = fs:update_path( '$game_config$', 'misc\\artefacts_cooking.ltx' )
    if not fs:exist( fname ) then
        wprintf( "[~T].~C0C #ERROR:~C07 file~C0A %s~C07 not exist - cannot use scheme.", fname )
        return
    end
    local ini        = ini_file( fname )
    local time_index = 'time'
    if not add_timer then add_timer = misc.game_timer() end
    -- через 4 минуты сбрасывается набор артефактов!
    if add_timer:elapsed( true ) > 240 then arts_added = {} end
    SetDbgVar( 'af_sect', af_sect )
    local ba = base_art( af_sect )
    table.insert( arts_added, af_sect ) -- tostring(ba)
    wprintf(
        "[~T]. #DBG(check_af_transform): artefact =~C0F %s~C07 (base =~C0E %s~C07), anomaly =~C0A %s~C07",
        af_sect, ba, anom_sect
    )
    wprintf( " arts_added: " )
    misc.dump_table( arts_added )
    ini:load( fname )
    local iobj = ini:object()
    local scc  = ini:section_count()
    for i = 0, scc - 1 do
        local scn       = ini:section_name( i )
        local sc        = iobj[ scn ]
        local good      = good_source( af_sect, sc.source or '?' )
        local anom_pass = strposx( anom_sect, sc.anomaly or '?' )
        local rlist     = sc.recipes or 'nil'
        if check_reciepts( rlist ) then
            if good and anom_pass then
                sc.auto_type = false
                af_flash( af )
                if enough_arts( sc.source or '?' ) then
                    arts_added     = {}
                    local p1, p2   = split_pair( sc.probability or "80,10", "," )
                    local hh, mm   = split_pair( sc[ time_index ], ":" )
                    local new_sect = scn:gsub( "cook.", "" ) -- секция создаваемого артефакта
                    local tr       = af_start_transform(
                                        tonumber( p1 ), tonumber( p2 ), af_sect, new_sect
                                     )
                    local desc     = game.translate_string( new_sect )
                    wprintf(
                        "[~T].~C0F #AMK_MOD:~C07 starting cooking~C0A %s~C07 with %s~C0F %s:%02d~C07, prob =~C0E %s, %s (%s)~C07",
                        new_sect, time_index, hh, mm, p1, p2, sc.probability or 'nil'
                    )
                    sak.store_anom_id( anom_id )
                    return af_start_transform_timer( tr, pos, 0, tonumber( hh ), tonumber( mm ), desc )
                else
                    wprintf(
                        "[~T].~C0F #AMK_MOD:~C07 cooking accepted ~C0A %s~C07 for mod~C0F %s~C07, but need more artefacts",
                        af_sect, scn
                    )
                end
            else
                wprintf(
                    "[~T].~C06 #AMD_MOD: ~C0A %-25s~C07 reject, need ~C0E %-25s~C0B (%s)~C07 in~C0F %-15s~C0B (%s)~C07, have ~C0B %s~C07",
                    scn, sc.source, DumpVar( good ), sc.anomaly, DumpVar( anom_pass ), af_sect
                )
            end
        else
            wprintf(
                "[~T].~C06 #AMD_MOD: ~C0A %-25s~C07 reject, need one reciept from ~C0E %-25s~C07 ",
                scn, rlist
            )
        end
    end
    sak.artmodscheck( anom_id, af, anom_sect )
end

function af_start_transform_timer( af, pos, delay_d, delay_h, delay_m )
    local gtime = misc.game_time_minutes()
    local t     = {}
    t.section   = af
    t.pos       = {}
    t.pos.x     = pos.x
    t.pos.y     = pos.y
    t.pos.z     = pos.z
    t.gv        = gv
    t.lv        = lv
    xvars.nlc[ "p_" .. gtime .. "_af" ] = t
    timers.start_timer(
        "af_trans_" .. gtime, delay_d, delay_h, delay_m,
        "amk_mod.af_transform_end(\"p_"..gtime.."_af\")"
    )
end

function af_transform_end( params_string )
    local prms = xray_vars.load_table( nlc_vars, params_string, {} )
    local sect = prms.section
    if not sect then
        wprintf(
            "~C0C #ERROR:~C07 af_transform_end loaded invalid table for~C0A %s~C07 ",
            params_string
        )
        dump_table( prms )
        return
    end
    local name      = amk.get_inv_name( sect )
    local from_sect = game.translate_string( name )
    local obj
    obj = amk.spawn_item(
        prms.section,
        vector():set( prms.pos.x, prms.pos.y + 1, prms.pos.z ),
        prms.gv, prms.lv
    )
    if obj then
        sobj = alife():object( obj.id )
        local pk = get_netpk( sobj, 1 )
        if pk:isOk() then
            local data        = pk:get()
            data.object_flags = bit_and( data.object_flags, bit_not( 128 ) )
            pk:set( data )
        end
    end
    vergas_art.add_in_tbl( obj )
    -- amk.add_spot_on_map(
    --     obj.id, "red_location", game.translate_string( "trans_finished_title" ) .. "%c[255,255,0,0]" .. from_sect
    -- )
    amk.send_tip( game.translate_string( "trans_finished_title" ) .. "%c[255,255,0,0]" .. from_sect )
    xvars.nlc[ params_string ] = nil
end

local beakons = {}

function check_beacon_drop( obj )
    if has_alife_info( "ui_car_body" ) then
        gps_habar.on_item_drop( obj )
    end
    if has_alife_info( "ui_inventory_hide" ) then return end
    if obj:section() == "amk_metka" then
        sak.close_window()
        beakons[ obj:id() ] = true
    end
end

function check_metka()
    amk_offline_alife.check_be_enemy()
    for id, v in pairs( beakons ) do
        local obj = client_obj( id )
        if obj then
            beakons[ id ] = nil
            if obj:parent() == nil then
                local spwn = ui_dots.dots( get_hud(), id )
                level.start_stop_menu( spwn, true )
            end
        end
    end
end

function blowout_phantoms()
    bt = bt or 0
    if bt >= 2 then return end
    local blow = amk_vars.blowout or 0
    if blow > 1 and blow < 4 then
        local lname = level.name()
        local a_pos = db.actor:position()
        if
            amk_anoms.check_coordinates( a_pos )
            and amk_hideouts.blowouts_phantoms[ lname ]
        then
            local phantoms = amk_hideouts.blowouts_phantoms[ lname ]
            if phantoms and phantoms.count > 0 then
                if lua_random() < phantoms.probability then
                    if phantom_manager:phantom_count() < phantoms.count then
                        local yaw    = math.pi * 2.0 * lua_random()
                        local radius = phantoms.radius * ( lua_random() / 2.0 + 0.5 )
                        local height = phantoms.height * lua_random()
                        local pos    = vector():set(
                            math.sin( yaw ) * radius + a_pos.x,
                            a_pos.y + height,
                            math.cos( yaw ) * radius + a_pos.z
                        )
                        phantom_manager.spawn_phantom( pos )
                    end
                end
            end
        end
    end
end

function blowout_scary_sounds()
    local blow = amk_vars.blowout or 0
    if blow > 0 and blow < 4 then
        local snd_obj = xr_sound.get_safe_sound_object(
            amk_hideouts.blowout_sounds[ lua_random( table.getn( amk_hideouts.blowout_sounds ) ) ]
        )
        local a = vector()
        a.x     = lua_random( 0, 10 )
        a.y     = lua_random( 0, 10 )
        a.z     = lua_random( 0, 10 )
        snd_obj:play_at_pos( db.actor, db.actor:position():add( a ) )
        timers.start_timer( "blowout_ss", lua_random( 10, 30 ), "amk_mod.blowout_scary_sounds()" )
        local name, delay = timers.check_timer( "blowout" )
        if not name then
            timers.start_timer( "blowout", 11, "amk_mod.Blowout_pp(0)" )
        end
    end
end

function blowout_psy_sound( action )
    if action == "start" then
        snd_obj_eq = sound_object( [[ambient\earthquake]], sound_object.looped + sound_object.s2d )
        snd_obj_eq:play( db.actor, 4, sound_object.looped + sound_object.s2d )
    end
    if action == "stop" then
        if snd_obj_eq then snd_obj_eq:stop() end
    end
    local lname = level.name()
    if not amk_hideouts.blowouts_phantoms[ lname ] then return end
    local psy_sound = amk_hideouts.blowouts_phantoms[ lname ].psy_sounds or false
    if not psy_sound then return end
    if action == "start" then
        local level_vol = amk_hideouts.blowouts_phantoms[ lname ].level_vol or 1
        sound_obj_right, sound_obj_left = xr_sound.get_sound_object( "psy_voices", "random" )
        sound_obj_left:play_at_pos(
            db.actor, vector():set( -1, 0, 1 ), 0, sound_object.s2d + sound_object.looped
        )
        sound_obj_right:play_at_pos(
            db.actor, vector():set( 1, 0, 1 ), 0, sound_object.s2d + sound_object.looped
        )
        snd_volume = level.get_snd_volume()
        level.set_snd_volume( level_vol )
    end
    if action == "stop" then
        if sound_obj_left  then sound_obj_left:stop()  end
        if sound_obj_right then sound_obj_right:stop() end
        if snd_volume then level.set_snd_volume( snd_volume ) end
    end
end

function Run_Blowout_pp()
    local bl_sl, bl_on = sleep_manager.sleep_blowout, ( amk_vars.blow_on or true )
    if bl_sl ~= false and bl_on ~= false then
        db.blowout_active = true
        amk_vars.blowout  = 1
        if bt < 1 then
            level.add_pp_effector( "monolith_off.ppe", 2003, false )
            level.add_cam_effector( "camera_effects\\shell_shock.anm", 2004, false,"" )
            local snd_obj = xr_sound.get_safe_sound_object( [[ambient\organic_moan1]] )
            snd_obj:play_no_feedback( db.actor, sound_object.s2d, 0, vector(), 1.0 )
        end
        sleep_manager.stopper()
        timers.start_timer( "blowout_ss", lua_random( 5, 15 ), "amk_mod.blowout_scary_sounds()" )
        timers.start_timer( "blowout", 11, "amk_mod.Blowout_pp(0)" )
    end
    start_blow_timer()
end

function start_blow_timer()     -- (36ч +/- 0..12ч) + 40мин в день.  К 100 дню +68 часов
    if lua_random() > 0.15 then
        amk_vars.blow_on = true
    else
        amk_vars.blow_on = false
    end
    local shift   = 1440
    local shift_p = ( math.floor( vergas_watch.time_days() ) * 40 ) or 1
    local t_time  = ( lua_random() * shift ) - ( shift / 2 ) + 2880 + shift_p
    timers.start_timer( "blow_shift", 0, 0, t_time, "amk_mod.Run_Blowout_pp()" )
    news_main.next_blow( t_time )
end

function Blowout_pp( num )
    ---------------------------------------------------
    --' TimeFactor           = 5
    --' GameMin              = 12 RealSec
    --' TimeBlowout          = 184 RealSec
    --' Начало(Timer         = 36 sec)
    --' Первая Фаза(Timer    = 36 sec)
    --' Вторая Фаза(Timer    = 36 sec)
    --' Третья Фаза(Timer    = 36 sec)
    --' Четвертая Фаза(Timer = 60 sec)
    --' Конечнвя Фаза(Timer  = 0 sec)
    ---------------------------------------------------
    local phase   = tonumber( num )
    local lname   = level.name() or "l01_escape"
    local time_hr = level.get_time_hours() or 0
    if phase == 0 then
        db.actor:give_info_portion( "vybros_info" )
        amk_anoms.pre_blow_off()
        if bt < 1 then
            dbg_set_w( "pre_blow", true )
            if     weather_types[ lname ] == 0 then
                dbg_set_w_fx( "amk_surge_day", true )
            elseif weather_types[ lname ] == 2 then
                dbg_set_w_fx( "amk_surge_day", true)
            elseif weather_types[ lname ] == 3 then
                dbg_set_w_fx( "amk_surge_day", true)
            elseif weather_types[ lname ] == 4 then
                dbg_set_w_fx( "amk_surge_day_depressive",true)
            elseif weather_types[ lname ] == 5 then
                dbg_set_w_fx( "amk_surge_day", true)
            end
        end
        timers.start_timer( "blowout", 0, 0, 3, "amk_mod.Blowout_pp(1)" )
    elseif phase == 1 then
        local snd_obj = xr_sound.get_safe_sound_object( [[ambient\earthquake]] )
        snd_obj:play_no_feedback( db.actor, sound_object.s2d, 0, vector(), 1.0 )
        level.add_cam_effector( "camera_effects\\earthquake.anm", 2002, true,"" )
        snd_obj = xr_sound.get_safe_sound_object( [[anomaly\blowout]] )
        snd_obj:play_no_feedback( db.actor, sound_object.s2d, 0, vector(), 1.0 )
        blowout_psy_sound( "start" )
        if bt < 1 then level.add_pp_effector( "vibros.ppe", 2001, true ) end
        in_hide = false
        timers.start_timer( "blowout", 0, 0, 3, "amk_mod.Blowout_pp(2)" )
        amk_vars.blowout = 2
    elseif phase == 2 then
        timers.start_timer( "blowout", 0, 0, 3, "amk_mod.Blowout_pp(3)" )
    elseif phase == 3 then
        amk_anoms.after_blow_on()
        sak.off_testobj()
        -- обновление таблицы id природных артов для статистики
        if nlc_vars.tbl_bio_art then nlc_vars.tbl_bio_art = nil end
        -- обновление таблицы id использованных для варок аномалий
        if nlc_vars.used_anomz then misc.dump_table( nlc_vars.used_anomz ) end
        if nlc_vars.used_anomz then nlc_vars.used_anomz = nil end
        amk_vars.blowout = 3
        timers.start_timer( "blowout", 0, 0, 3, "amk_mod.Blowout_pp(4)" )
    elseif phase == 4 then
        amk_vars.blowout = 4
        level.remove_cam_effector( 2002 )
        if bt < 1 then
            level.remove_pp_effector( 2001 )
            level.add_pp_effector( "monolith_off.ppe", 2003, false )
        end
        blowout_psy_sound( "stop" )
        timers.start_timer( "blowout", 5, "amk_mod.Blowout_pp(5)" )
        amk_anoms.generate_arts()
    elseif phase == 5 then
        --dbg_set_w( amk_vars.weather or default, true )
        if bt < 1 then
            local snd_obj = xr_sound.get_safe_sound_object( [[anomaly\teleport_work2]] )
            snd_obj:play_no_feedback( db.actor, sound_object.s2d, 0, vector(), 1.0 )
            if     weather_types[ lname ] == 0 then
                dbg_set_w( "amk_groza_groza_" .. time_hr, true )
                amk_vars.dynweather = "amk_groza_groza_" .. time_hr
            elseif weather_types[ lname ] == 2 then
                dbg_set_w( "amk_groza_groza_no_far_" .. time_hr, true )
                amk_vars.dynweather_no_far = "amk_groza_groza_no_far_" .. time_hr
            elseif weather_types[ lname ] == 3 then
                dbg_set_w( "amk_groza_groza_mist_" .. time_hr, true )
                amk_vars.dynweather_mist = "amk_groza_groza_mist_" .. time_hr
            elseif weather_types[ lname ] == 4 then
                dbg_set_w( "amk_groza_groza_depressive_" .. time_hr, true )
                amk_vars.dynweather_depressive = "amk_groza_groza_depressive_" .. time_hr
            elseif weather_types[ lname ] == 5 then
                dbg_set_w( "amk_groza_groza_storm_" .. time_hr, true )
                amk_vars.dynweather_storm = "amk_groza_groza_storm_" .. time_hr
            end
            amk_vars.last_dynw   = "groza"
            amk_vars.dynw        = "groza"
            amk_vars.dynlasthour = time_hr
            amk_vars.dynweather  = "amk_groza_groza_" .. time_hr
        end
        amk_vars.blowout  = nil
        db.blowout_active = false
        db.actor:give_info_portion( "groza_info" )
        -- для статистики:
        xr_statistic.add_pts(
            "stalkerkills", game.translate_string( "st_pda_blowouts_num" ), 1, 0
        )
        test.blowout_damage_equipment()
        if
            lua_random() > 0.83
            and sak.have_items_count( "batt_torch", 1 )
        then
            timers.start_timer( "fuckup_batt_torch_all", 0, 0, 32, "test.fuckup_gg_batteries(true)" )
        end
        test.update_r_treas_items()
        -- sleep_manager.change_sleepiness(25, true) -- увеличить сонливость, зачем?
    end
end

local next_actor_hit_time = 0

function on_blowout_hit_actor()
    if ( amk_vars.blowout or -1 ) ~= 3 then return end
    if next_actor_hit_time < time_global() then
        next_actor_hit_time = time_global() + 1000
        on_blowout_hit( db.actor )
    end
end

function on_blowout_hit( npc, hide )
    bt = bt or 0
    if bt > 0 or ( amk_vars.blowout or -1 ) ~= 3 then
        if npc:id() == db.actor:id() then in_hide = true end
        return false
    end
    local lname = level.name()
    local need_hit
    need_hit   = true
    local khit = 1
    if hide and hide.zone then
        need_hit = not check_npc_in_hideout( npc, hide )
        if not need_hit then
            if hide.defence then
                khit = hide.defence
            else
                khit = 0
            end
        end
    else
        local hides = amk_hideouts.hide[ lname ]
        local tmp
        if hides then
            for i, o in ipairs( hides ) do
                if o.zone then
                    for j, v in ipairs( o.zone ) do
                        if v.p3 then
                            tmp = amk.check_npc_in_box(
                                npc,
                                vector():set( unpack( v.p1 ) ),
                                vector():set( unpack( v.p2 ) ),
                                vector():set( unpack( v.p3 ) )
                            )
                        else
                            tmp = amk.check_npc_in_box(
                                npc,
                                vector():set( unpack( v.p1 ) ),
                                vector():set( unpack( v.p2 ) )
                            )
                        end
                        need_hit = need_hit and not tmp
                        if tmp then
                            if o.defence then
                                khit = o.defence
                            else
                                khit = 0
                            end
                        end
                    end
                end
            end
        end
    end
    if npc:id() == db.actor:id() then in_hide = not need_hit end
    if ( need_hit or khit > 0 ) and ( amk_vars.blowout or -1 ) == 3 then
        local power = ( amk_hideouts.blowout_damages[ lname ] or 0.01 ) * khit
        if npc:id() == db.actor:id() then
            params.psy_health_add( -power )
            params.radiation_add( power )
            power = -( power / 2 )
            params.health_add( power )
        else
            local h     = hit()
            h.power     = power
            h.impulse   = 0
            h.draftsman = npc
            h.direction = vector():set( 0, 0, 0 )
            h:bone( "bip01_spine" )
            h.type      = hit.strike
            npc:hit( h )
            h.type      = hit.telepatic
            npc:hit( h )
            h.type      = hit.radiation
            npc:hit( h )
        end
    end
    return need_hit or khit > 0
end

function check_npc_in_hideout( npc, hide )
    local not_in_zone = true
    if hide and hide.zone then
        for k, v in pairs( hide.zone ) do
            if v.p3 then
                not_in_zone = not_in_zone and not amk.check_npc_in_box(
                    npc,
                    vector():set( unpack( v.p1 ) ),
                    vector():set( unpack( v.p2 ) ),
                    vector():set( unpack( v.p3 ) )
                )
            else
                not_in_zone = not_in_zone and not amk.check_npc_in_box(
                    npc,
                    vector():set( unpack( v.p1 ) ),
                    vector():set( unpack( v.p2 ) )
                )
            end
        end
    end
    return not not_in_zone
end

function blowout_type()
    local lname = level.name()
    local t     = amk_hideouts.blowout_types[ lname ]
    return t or 0
end

local safe_levels = {
    [ "l01_escape"           ] = true,
    [ "l03_agroprom"         ] = true
    --[ "l02_garbage"          ] = true,
    --[ "l03u_agr_underground" ] = true,
    --[ "k01_darkscape"        ] = true,
    --[ "hospital"             ] = true
}

local comm_black_tip = {
    [ "stalker"  ] = true,
    [ "freedom"  ] = true,
    [ "dolg"     ] = true,
    [ "bandit"   ] = true,
    [ "killer"   ] = true,
    [ "military" ] = true
}

function IsStalkerCorpse( prn_id )
    local npc = client_obj( prn_id )
    if IsStalker( npc ) then
        local comm = npc:character_community()
        return comm_black_tip[ comm ]
    end
    return false
end

function try_add_black_tip( lname, prn_id )
    info = "info_black_tip"
    if safe_levels[ lname ] or not IsStalkerCorpse( prn_id ) then return false end
    if lua_random( 100 ) <= 2 and not has_alife_info( info ) then
        timers.start_timer( "black_tip_hv", 8, 1, 1, "sak_dialog.take_black_tip()" )
        db.actor:give_info_portion( info )
        return true
    end
    return false
end

function check_usable_item( obj )
    local lname   = level.name()
    local info    = nil
    local actor   = db.actor
    local section = obj:section()
    if section == "amk_metka" then
        amk.remove_spot_from_map( obj:id(), "red_location" )
        beakons[ obj:id() ] = nil
    elseif string.find( obj:section(), "^wpn_" ) then
        fast_wpn_textures()
    elseif string.find( obj:section(), "outfit" ) then
        schedule.add("outf_paus", "amk_mod.fast_wpn_textures()", 200 )
    elseif section == "vehicle_btr" then
        actor:kill( actor )
    end
    if section == "amk_zapiska" then
        if     lname == "l01_escape" then
            info = test.rnd_rec_art_info( test.tbl_recipt, 5 ) --блок на кордоне?
        elseif lname == "l08u_brainlab" then
            info = test.rnd_rec_art_info( test.tbl_recipt, 7 ) --в х16?
        else
            return
        end
        amk.drop_item( actor, obj )
        amk.remove_item( obj )
    end
    if actor == nil or info == nil or actor:has_info( info ) then return end
    test.sms_recipt_found( info )
    actor:give_info_portion( info )
end

function generate_recipe( obj )
    if not IsStalker( obj ) or obj:alive() then return end
    local info = nil
    local prob = 100
    if
        level.name() == "l07_military"
        and obj.character_community
        and (
               obj:character_community() == "killer"
            or obj:character_community() == "freedom"
        )
    then
        info = "info_amk_recipt_titan_kolobok"
        prob = 30
    elseif
        level.name() == "l10_radar"
        and obj.character_community
        and obj:character_community() == "monolith"
    then
        info = "info_amk_recipt_controller_skalp"
        prob = 10
    elseif
        level.name() == "limansk"
        and obj.character_community
        and obj:character_community() == "stalker"
    then
        info = "info_amk_recipt_stone_dikoobraz"
        prob = 30
    end
    if not info then return end
    local recipes = xray_vars.load_table( amk_vars, "amk_body_recipe", {} )
    for k, v in pairs(recipes) do
        if v == info then return end
    end
    if lua_random( 100 ) <= prob then
        recipes[ obj:id() ]      = info
        amk_vars.amk_body_recipe = recipes
    end
end

function spawn_fuel()
    local ballons = {
        {   58.30,  19.36,   156.50, 345136,   97 },
        { -118.00,  -2.49, -192.783,  97199,  269 },
        {  -74.17,   1.80,     8.45, 127766,  329 },
        {    3.18,   1.24,    42.48, 243919,  490 },
        {   15.35,  -1.90,     2.40, 255433,  479 },
        {   77.54,   0.30,  -108.47, 312366,  427 },
        { -145.54,  -0.00,  -199.61,  92520,  650 },
        { -130.08,  10.00,  -196.67, 109214,  629 },
        { -140.13,  10.00,  -197.94,  98647,  629 },
        {   37.28,   1.02,   -49.90, 220638, 1084 },
        {  476.68, -46.94,    -0.23, 155714, 1919 },
        {   76.80,  -2.54,   -23.93,  36304, 1970 },
        {   94.78,   0.03,    -6.88,  88986, 1514 },
        {   -3.24, -11.75,  -263.07,  33794, 1448 }
    }
    -- local kanisters = {
    -- {5.864511013031,0.65,297.02972412109,282644,186},
    -- {353.74182128906,16.96,249.29316711426,590705,251},
    -- {-69.94, 0.97, 6.51, 131411, 329},
    -- {64.01, 0.60, 148.46, 235341, 364},
    -- {63.29, -0.20, 5.10, 299326, 461},
    -- {-28.52, -1.04, -181.84, 211644, 676},
    -- {2.93, -1.88, -13.30, 176553, 1047},
    -- {41.71, 4.54, -86.36, 227110, 1100},
    -- {7.90, 1.41, -71.93, 183138, 1041},
    -- {158.71, -0.76, -259.73, 358950, 962},
    -- {-344.63,-12.82,400.97, 9612, 1847},
    -- {305.22, -36.99, -24.40, 68330, 1930},
    -- {55.02, 1.17, 40.35, 68094, 1511},
    -- {-114.14, -0.00, 121.75, 43453, 1315},
    -- {31.33, 5.60, -13.51, 4683, 1538}
    -- }
    for k, v in pairs( ballons ) do
        local obj = g_sim:create(
            "amk_ballon",vector():set(v[ 1 ], v[ 2 ], v[ 3 ] ), v[ 4 ], v[ 5 ]
        )
    end
    -- for k,v in pairs(kanisters) do
    --     local obj = g_sim:create("amk_kanistra",vector():set(v[1], v[2], v[3]), v[4], v[5])
    -- end
end

function spawn_military_btr()
    local obj, pk, data
    local tbl = {
        {
            "vehicle_btr",
            -168.11, -29.65, -303.21, 81808, 38, 100,
            "[logic]\ncfg = scripts\\esc\\esc_blockpost_btr.ltx",
        },
        {
            "vehicle_btr",
            -237.85, -26.15, -378.81, 17147, 14, 100,
            "[logic]\ncfg = scripts\\esc\\esc_blockpost_btr.ltx",
        },
        {
            "vehicle_btr",
            -191.32, 0.09, -120.19, 45517, 446, 100,
            "[logic]\ncfg=scripts\\agr\\agr_blockpost_btr.ltx",
        },
        {
            "vehicle_btr",
            -93.81, 0, -185.82, 146369, 607, 100,
            "[logic]\ncfg=scripts\\agr\\agr_blockpost_btr.ltx",
        },
        {
            "helicopter",
            -150.0, -40.0, -620.0, 128298, 11, 50,
            "[logic]\ncfg = scripts\\esc\\esc_blockpost_heli.ltx",
        }
    }
    for i = 1, #tbl do
        obj = g_sim:create(
            tbl[ i ][ 1 ],
            vector():set(tbl[ i ][ 2 ], tbl[ i ][ 3 ], tbl[ i ][ 4 ] ),
            tbl[ i ][ 5 ], tbl[ i ][ 6 ]
        )
        pk                = get_netpk( obj, 1 )
        data              = pk:get()
        data.object_flags = bit_not( 5 )
        data.custom_data  = tbl[ i ][ 8 ]
        data.mass         = tbl[ i ][ 7 ]
        if tbl[ i ][ 1 ] == "helicopter" then
            data.engine_sound = "alexmx\\helicopter"
        end
        pk:set( data )
    end
end

dynweathers = {
    clear = {
        clear    = 70,
        pasmurno = 15,
        rain     = 10,
        groza    = 5
    },
    pasmurno = {
        clear    = 60,
        rain     = 10,
        groza    = 5,
        pasmurno = 25
    },
    rain = {
        clear    = 25,
        groza    = 20,
        pasmurno = 30,
        rain     = 25
    },
    groza = {
        clear    = 20,
        rain     = 20,
        pasmurno = 30,
        groza    = 30
    }
}

function weather_manager()
    if sync_done == false then return end
    local lname       = level.name()
    local hour        = level.get_time_hours()
    local dynlasthour = amk_vars.dynlasthour or 1
    if dynlasthour ~= hour then
        sak.consum_artefact( hour )
        sak.info_days( hour )
        local next_weather
        local rnd  = lua_random( 0, 100 )
        local dynw = amk_vars.dynw or "pasmurno"
        for k, v in pairs( dynweathers[ dynw ] ) do
            if rnd <= v then
                next_weather = k
                break
            end
            rnd = rnd - v
        end
        db.actor:give_info_portion( next_weather .. "_info" )
        if
            (( amk_vars.blowout or 0 ) == 0 and bt < 1 )
            and weather_types[ lname ] == 0
        then
            dbg_set_w( "amk_" .. dynw .. "_" .. next_weather .. "_" .. hour, true )
        elseif  weather_types[ lname ] == 1 then dbg_set_w( "indoor", true )
        elseif
            (( amk_vars.blowout or 0 ) == 0 and bt < 1 )
            and weather_types[ lname ] == 2
        then
            dbg_set_w( "amk_" .. dynw .. "_" .. next_weather .. "_no_far_" .. hour, true )
        elseif
            (( amk_vars.blowout or 0 ) == 0 and bt < 1 )
            and weather_types[ lname ] == 3
        then
            dbg_set_w( "amk_" .. dynw .. "_" .. next_weather .. "_mist_" .. hour, true )
        elseif
            (( amk_vars.blowout or 0 ) == 0 and bt < 1 )
            and weather_types[ lname ] == 4
        then
            dbg_set_w( "amk_" .. dynw .. "_" .. next_weather .. "_depressive_" .. hour, true )
        elseif
            (( amk_vars.blowout or 0 ) == 0 and bt < 1 )
            and weather_types[ lname ] == 5
        then
            dbg_set_w( "amk_" .. dynw .. "_" .. next_weather .. "_storm_" .. hour, true )
        end
        if news_main and news_main.on_weather_change then
            news_main.on_weather_change( dynw, next_weather )
        end
        amk_vars.last_dynw             = dynw
        amk_vars.dynw                  = next_weather
        amk_vars.dynlasthour           = hour
        amk_vars.dynweather            = "amk_" .. dynw .. "_" .. next_weather .. "_" .. hour
        amk_vars.dynweather_no_far     = "amk_" .. dynw .. "_" .. next_weather .. "_no_far_" .. hour
        amk_vars.dynweather_mist       = "amk_" .. dynw .. "_" .. next_weather .. "_mist_" .. hour
        amk_vars.dynweather_depressive = "amk_" .. dynw .. "_" .. next_weather .. "_depressive_" .. hour
        amk_vars.dynweather_storm      = "amk_" .. dynw .. "_" .. next_weather .. "_storm_" .. hour
    end
end

function switch_monster_online( obj )
    se_monster.need_be_online[ obj.id ] = true
end

function switch_monster_offline( obj )
    se_monster.need_be_online[ obj.id ] = false
end

local sini = ini_file( "scripts\\amk\\amk_respawns.ltx" )

function respawned( obj, respawner )
    if IsMonster(obj) then
    local cfg_name
    local path_home       = utils.cfg_get_string( sini,respawner.amk_name,"path_home", false, false, false,"" )
    local home_min_radius = utils.cfg_get_string( sini,respawner.amk_name,"home_min_radius", false, false, false,"" )
    local home_max_radius = utils.cfg_get_string( sini,respawner.amk_name,"home_max_radius", false, false, false,"" )
    local timer_agr       = tostring( lua_random( 11, 43 ) * 997 )
    local timer_stop      = tostring( lua_random( 9, 31  ) * 997 )
    if     strpos( respawner.amk_name, "dead_zomb", 1, true ) then
        cfg_name = "[smart_terrains]\nnone=true\n[logic]\nactive = mob_fake_death\n[mob_fake_death]\non_actor_dist_le_nvis = 10 | mob_home\n[mob_home]\npath_home = "..path_home.."\nhome_min_radius = "..home_min_radius.."\nhome_max_radius = "..home_max_radius.."\naggressive_home\non_actor_dist_ge_nvis = 20 | mob_fake_death\non_signal = sig_attacked | mob_combat\non_timer = "..timer_agr.." | %=bar_arena_hit%  mob_combat\n[mob_combat]\non_timer = "..timer_stop.." | mob_home\non_actor_dist_ge_nvis = 30 | mob_fake_death"
    elseif strpos( respawner.amk_name, "x10_zomb", 1, true ) then
        cfg_name = "[smart_terrains]\nnone=true\n[logic]\nactive = mob_fake_death\n[mob_fake_death]\non_actor_dist_le_nvis = 10 | mob_home\n[mob_home]\npath_home = "..path_home.."\nhome_min_radius = "..home_min_radius.."\nhome_max_radius = "..home_max_radius.."\naggressive_home\non_actor_dist_ge_nvis = 20 | mob_fake_death\non_signal = sig_attacked | mob_combat\non_timer = "..timer_agr.." | %=bar_arena_hit%  mob_combat\n[mob_combat]\non_timer = "..timer_stop.." | mob_home\non_actor_dist_ge_nvis = 25 | mob_fake_death"
    elseif strpos( respawner.amk_name, "_zomb", 1, true ) then
        cfg_name = "[smart_terrains]\nnone=true\n[logic]\nactive = mob_fake_death\n[mob_fake_death]\non_actor_dist_le_nvis = 25 | mob_home\n[mob_home]\npath_home = "..path_home.."\nhome_min_radius = "..home_min_radius.."\nhome_max_radius = "..home_max_radius.."\naggressive_home\non_actor_dist_ge_nvis = 60 | mob_fake_death\non_signal = sig_attacked | mob_combat\non_timer = "..timer_agr.." | %=bar_arena_hit%  mob_combat\n[mob_combat]\non_timer = "..timer_stop.." | mob_home\non_actor_dist_ge_nvis = 80 | mob_fake_death"
    else
        local home_min_radius_n = tostring( math.ceil( tonumber( home_min_radius ) / 1.5 ) )
        local home_max_radius_n = tostring( math.ceil( tonumber( home_max_radius ) / 1.5 ) )
        cfg_name = "[smart_terrains]\nnone=true\n[logic]\nactive = mob_home@0\n[mob_home@0]\non_info={+time_night} mob_home@1\npath_home = "..path_home.."\nhome_min_radius = "..home_min_radius.."\nhome_max_radius = "..home_max_radius.."\naggressive_home\non_signal = sig_attacked | mob_combat\non_timer = "..timer_agr.." | %=bar_arena_hit%  mob_combat\n[mob_combat]\non_timer = "..timer_stop.." | mob_home@0\n[mob_home@1]\non_info={-time_night} mob_home@0\npath_home = "..path_home.."\nhome_min_radius = "..home_min_radius_n.."\nhome_max_radius = "..home_max_radius_n.."\naggressive_home\non_signal = sig_attacked | mob_combat\non_timer = "..timer_agr.." | %=bar_arena_hit%  mob_combat"
    end
    local pk         = get_netpk( obj )
    local data       = pk:get()
    data.custom_data = cfg_name
    pk:set( data )
    local conds = {}
    conds[ "none" ] = xr_logic.parse_condlist( obj, "smart_terrains", "none", "true" )
    obj.smart_terrain_conditions = conds
    --ODS("[~T/~B]. #DBG: монстр = "..obj:name().."  респавнер  "..respawner.amk_name.."   конфиг    "..cfg_name)
    end
end

local respawners = {}

function spawn_unspawned_respawners()
    local ids,cnt = registry.clsid_objects( CLID_RESPAWN, CLID_RESPAWN, true, nil, 15 )
    for n = 1,cnt do
        local id  = ids[ n ]
        local obj = g_sim:object( id )
        if obj then
            local oini = obj:spawn_ini()
            if oini:line_exist( "respawn", "amk_name" ) == true then
                local amk_name = utils.cfg_get_string( oini, "respawn", "amk_name", false, false, false, false )
                if amk_name then respawners[ amk_name ] = true end
                --ODS("[~T/~B]. #DBG: amk_name = "..tostring(amk_name).." "..obj:name())
            end
        end
    end
    local dv = {}
    if sini:section_exist( "default_values" ) then
        local result, id, value = nil, nil, nil
        for a = 0, sini:line_count( "default_values" ) - 1 do
            result, id, value = sini:r_line( "default_values", a, "", "" )
            if id ~= nil and amk.trim( id ) ~= "" and amk.trim( id ) ~= nil then
                dv[ amk.trim( id ) ] = amk.trim( value )
            end
        end
    end
    if sini:section_exist( "amk_respawns" ) then
        local tmp = {}
        local result, id, value = nil, nil, nil
        for a = 0, sini:line_count( "amk_respawns" ) - 1 do
            result, id, value = sini:r_line( "amk_respawns", a, "", "" )
            if id ~= nil and amk.trim( id ) ~= "" and amk.trim( id ) ~= nil then
                table.insert( tmp, amk.trim( id ) )
            end
        end
        for k, v in pairs( tmp ) do
            --local flag = utils.cfg_get_bool(sini,"amk_respawns", v, true, false, false)
            local map = utils.cfg_get_string( sini, "amk_respawns", v, false, false, false, "" )
            if not respawners[ v ] and map == level.name() then
                local t         = amk.parse_ini_section_to_array( sini, v )
                local xyzlg     = amk.str_explode( ",", t.xyzlg, true )
                local pos       = vector():set(
                                    tonumber( xyzlg[ 1 ] ),
                                    tonumber( xyzlg[ 2 ] ),
                                    tonumber( xyzlg[ 3 ] )
                                  )
                local respawner = amk.spawn_item(
                                    "respawn", pos,
                                    tonumber( xyzlg[ 5 ] ), tonumber( xyzlg[ 4 ] )
                                  )
                --ODS("[~T/~B]. #DBG: amk_name = "..xyzlg[5].." "..xyzlg[4])
                t.xyzlg    = nil
                t.amk_name = v
                for kkk, vvv in pairs( dv ) do
                    if t[ kkk ] == nil then t[ kkk ] = vvv end
                end
                local pk         = get_netpk( respawner )
                local data       = pk:get()
                data.custom_data = amk.gen_custom_data( { respawn = t } )
                pk:set( data )
                se_respawn.reinit_spawner_params( respawner:name() )
                --amk.add_spot_on_map(respawner.id,"red_location", v.."//n"..tbl.custom)
                --amk.mylog("spawned respawn "..respawner.id)
            end
            --[[if flag==false then
            local o = se_respawn.get_respawner_by_name(v)
            if o then
            g_sim:release(o)
            end
            end--]]
        end
    end
end

local last_armor_id = 0
last_condition = 0

function repair_armor( val )
    local armor = db.actor:item_in_slot( 6 )
    if armor then
        last_armor_id  = armor:id()
        last_condition = val
        armor:set_condition( val )
    end
end

function check_armor()
    for slot = 0, 4 do
        local item = db.actor:item_in_slot( slot )
        if
            item
            and item:get_weapon() ~= nil
            and false == strpos( item:section(), "knife" )
            and slot ~= 3
        then
            params.weapon_mag_size_cond_check( item, slot )
        end
    end
    local armor = db.actor:item_in_slot( 6 )
    if not armor then
        last_armor_id = 0
        params.outfit_weight_cond( nil, 0.03 )
        return
    end
    local cond = armor:condition()
    if armor:id() ~= last_armor_id then
        last_armor_id = armor:id()
        params.outfit_weight_cond( armor, 0 )
        last_condition = 0.1
        return
    end
    if math.abs( last_condition - cond ) > 0.05 then
        params.outfit_weight_cond( armor, cond )
        last_condition = cond
    end
end

function fast_wpn_textures()
    local armor   = db.actor:item_in_slot( 6 )
    last_armor_id = 0
    for slot = 0, 4 do
        local item = db.actor:item_in_slot( slot )
        if
            item and
            item:get_weapon() ~= nil
            and false == strpos( item:section(), "knife" )
            and slot ~= 3
        then
            params.weapon_mag_size_cond_check( item, slot )
        end
    end
    params.outfit_weight_cond( armor, 0.15, true )
end

function dezombify( id, v )
    local npc = client_obj(id)
    if npc then
        if npc:alive() == false then return true end
        local sobj = g_sim:object( id )
        if sobj then
            npc:set_character_community( v.comm, 0, 0 )
            npc:set_goodwill( v.gw, db.actor )
            local pk               = get_netpk( sobj )
            local data             = pk:get()
            data.character_profile = string.gsub( data.character_profile, "(.*)_zombi", "%1" )
            pk:set( data )
            return true
        end
    end
    return false
end

btrs_friends = {}

function build_btrs_table( obj )
    if
        obj
        and ( IsStalker( obj ) and obj:character_community() == "military" and obj:alive() )
        or obj:section() == "vehicle_btr"
    then
        btrs_friends[ obj:id() ] = obj:section()
    end
end

function firebated( obj, amount, local_direction, who, bone_index )
    if bone_index >= 0 and who and IsStalker( who ) then
        local weapon = who:active_item()
        if
            not weapon
            or weapon:section() ~="wpn_flame"
            or who:position():distance_to( obj:position() ) > 12
        then
            return
        end
        if  (
                string.find( obj:section(), "poltergeist", 1, true )
                and not string.find( obj:section(), "_flame", 1, true )
            )
            or string.find( obj:section(), "zomb", 1, true )
        then
            if obj.health < 0.3 then
                obj:kill( obj )
            else
                local h     = hit()
                h.type      = hit.burn
                h.power     = 50
                h.impulse   = 0.1
                h.draftsman = who
                h.direction = vector():set( 0, -1, 0 )
                obj:hit( h )
            end
        end
        -- добавить жару из огнемета:
        flamethrower.set_fire( obj )
    end
end

local zombi_skeletons = {
    "physics\\dead_body\\skelet_combine_pose_03",
    "physics\\dead_body\\skelet_combine_pose_04",
    "physics\\dead_body\\skelet_combine_pose_05",
    "physics\\dead_body\\skelet_torso"
}

function zomby_blow( obj )
    if obj:object( "wpn_flame" ) then
        amk_particle.amk_particle({
            particle = "explosions\\explosion_fuelcan",
            pos      = obj:position(),
            sound    = [[weapons\t_rgd5_explosion]]
        })
        local dist = db.actor:position():distance_to( obj:position() )
        if dist < 10 and db.actor:see( obj ) then
            local h     = hit()
            h.impulse   = 0
            h.draftsman = db.actor
            h.direction = vector():set( 0, 0, 0 )
            h:bone( "bip01_spine" ) -- чтобы учитывалась броня
            h.power     = 1 / dist
            h.type      = hit.strike --chemical_burn
            db.actor:hit( h )
            h.power     = 15 / dist
            h.type      = hit.chemical_burn
            db.actor:hit( h )
        end
        g_sim:release( g_sim:object( obj:id() ) )
        return
    end
    if obj:section() == "zombie_blow" then
        amk_particle.amk_particle({
            particle = "amk\\zomb_explode",
            pos      = obj:position(),
            sound    = [[anomaly\anomaly_body_tear_1]]
        })
        local dist = db.actor:position():distance_to( obj:position() )
        if dist < 30 and db.actor:see( obj ) then
            local h     = hit()
            h.impulse   = 0
            h.draftsman = db.actor
            h.direction = vector():set( 0, 0, 0 )
            h:bone( "bip01_spine" )
            h.power     = 1 / dist
            h.type      = hit.strike
            db.actor:hit( h )
            h.power     = 15 / dist
            h.type      = hit.chemical_burn
            db.actor:hit( h )
        end
        local skel  = amk.spawn_item(
            "breakable_object", obj:position(), obj:game_vertex_id(), obj:level_vertex_id()
        )
        local pk         = get_netpk( skel, 1 )
        local t          = pk:get()
        t.visual_name    = zombi_skeletons[ lua_random( table.getn( zombi_skeletons ) ) ]
        t.mass           = 5.0
        t.physic_type    = 3
        t.skeleton_flags = 1
        t.visual_flags   = 1
        ODS( "[~T/~B]. #DBG: zomby_blow net_packet: " )
        dump_table( t, "  " )
        pk:set( t )
        LuaSafeCall( "misc.process_spawn", "#func:^dbg" )
        obj:set_position( vector():set( 0, -500, 0 ) ) -- скрыть с глаз долой
        misc.release_obj( obj, "remove_zombie_body", false )
        ODS( "[~T/~B]. #DBG: zomby_blow complete" )
    end
end

function firebat_ammo()
    local ammo = db.actor:object( "ammo_flame" )
    if ammo then
        db.actor:iterate_inventory(
            function( dummy, item )
                if item:section() == "ammo_flame" then
                    g_sim:release( g_sim:object( item:id() ) )
                end
            end,
            db.actor
        )
    end
end

function init_module() end
function late_init() end

bt = blowout_type()