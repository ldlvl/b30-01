off_npcs        = {}
items           = {}
relation_matrix = {}
tables_ready    = false

ini_trade_generic = ini_file( "misc\\trade_generic.ltx" )
ini_death_generic = ini_file( "misc\\death_generic.ltx" )

local sell_table       = {}
local item_dependence  = {}
local always_keep_item = {}
local sini             = system_ini()
local wpn_fp           = {}
local item_cost        = {}
local bFlag            = false
local iCounter         = 108
local iTime            = -1
local iFreq            = 37
local initialized      = false
local monster_params   = {}

function can_be_online( obj )
    return obj and obj.can_switch_online and obj:can_switch_online()
end

local maps = {
    "l01_escape",
    "l02_garbage",
    "l03_agroprom",
    "l03u_agr_underground",
    "l04_darkvalley",
    -- "l04u_labx18",
    "l05_bar",
    "l06_rostok",
    "l07_military",
    "l08_yantar",
    -- "l08u_brainlab",
    -- "l10_radar",
    "limansk",
    "lost_village",
    "marsh",
    "red_forest",
    "k01_darkscape",
    -- "warlab",
    -- "labx10",
    -- "labx8",
    "generators",
    "aver",
    "hospital",
    "deadcity",
    -- "av_peshera",
    -- "l10u_bunker",
    "l11_pripyat"
    -- "l12_stancia",
    -- "l12_stancia_2",
    -- "l12u_control_monolith",
    -- "l12u_sarcofag"
}

local protected = {
    2290, 2281, 2282, 2283, 2284, 2285, 2286, 2287, 2288, 2289,
    2280, 2291, 2292, 2293, 2294, 2295, 2296, 2297, 2298, 2299,
    2230, 2231, 2232, 2233, 2234, 2235, 2236, 2237, 2238, 2239,
    2240, 2241, 741,  742,  9140, 9141, 9142, 9132, 9143, 9144,
    5862, 31,   9115, 9514, 9557    
}

local smart_filters = { "esc_bridge", "esc_blokpost" }

local rel_enemy, rel_friend
local look_radius        = 0
local search_intensivity = 30
local max_rounds         = 10
local health_wound       = 0.1
local health_wound_set   = 0.02
local base_fp            = 1400
local dist_coeff         = 8
local sell_limit         = 15000
local rate_kill_base     = 50
local rate_art_found     = 15
local to_actor           = 100
local look_radius_box    = 100
local look_radius_ruksak = 200
local look_radius_hide1  = 20
local look_radius_hide2  = 40
local body_blow_id       = nil

local function perf_log( fmt, ... )
    wprintf( "[~T/~U/~B].~C0B #PERF_AOA: " .. fmt .. "~C07", ... ) 
end

function init()
    if initialized == false then
        load_scheme( "xr_punch_tm", "punch_tm", stype_stalker )
        build_tables()
        initialized = true
    end
end

function update()
    if iCounter < BAD_OBJ_ID then
        local obj
        for i = 1, 2 do
            obj = g_sim:object( iCounter )
            if obj then add_fresh_meat( obj ) end
            iCounter = iCounter + 1
            if iCounter >= BAD_OBJ_ID then break end
        end
    else
        iCounter = 108
    end
end

function add_fresh_meat( obj )
    if not obj then return end
    local g_vert = obj.m_game_vertex_id
    local o_id   = obj.id
    local o_sect = obj:section_name()
    local o_sid  = obj.m_story_id
    local o_pid  = obj.parent_id
    local o_name = obj:name()
    local flt    = {
        "brkbl",
        "changer",
        "clmbl#",
        "barrel",
        "hanging",
        "m_crow",
        "_object",
        "physic",
        "restrictor",
        "smart_terrain",
        "zone_"
    }  
    if get_bool( obj:section_name(), "watcher_act.bad_item", false ) then return end
    if str_in_tab( o_name, flt ) or str_in_tab( o_sect, flt )        then return end
    if g_vert and db.actor and db.actor:id() ~= o_id then
        if game_graph():valid_vertex_id( g_vert ) then
            local map = g_sim:level_name( game_graph():vertex( g_vert ):level_id() )
            if not off_npcs[ map ] then
                off_npcs[ map ] = {
                    monsters  = {},
                    stalkers  = {},
                    weapons   = {},
                    artefacts = {},
                    inv_boxes = {}
                }
            end
            get_item_cost( obj )
            if IsMonster( obj ) and obj.alive and obj:alive() and obj.health and obj:health() > 0 then
                local flags = get_flags( o_id )
                if flags == 0 or flags == 2 then
                    table.insert( off_npcs[ map ].monsters, { id = o_id, name = o_name } )
                end
            elseif
                ( o_sect == "inventory_box" or o_sect == "m_inventory_box" or o_sect == "rucksack" )
                and box_is_protected( obj ) ~= true
            then
                table.insert( off_npcs[ map ].inv_boxes, { id = o_id, name = o_name } )
            elseif IsStalker( obj ) and obj.alive and obj:alive() then
                if
                    obj.health
                    and obj:health() > 0
                    and o_sid ~= nil
                    and ( o_sid == NONE_SID or o_sid == NONE_CL_SID )
                then
                    local flags = get_flags( o_id )
                    if flags == 0 or flags == 2 then
                        if obj:community() ~= "zombied" then
                            table.insert( off_npcs[ map ].stalkers, { id = o_id, name = o_name } )
                        else
                            table.insert( off_npcs[ map ].monsters, { id = o_id, name = o_name } )
                        end
                    end
                end
            elseif isWeapon( obj ) then
                load_weapon_params( obj )
                if o_sid == nil or o_sid == NONE_SID or o_sid == NONE_CL_SID then
                    if ( o_pid ~= nil and o_pid ~= BAD_OBJ_ID and o_pid ~= 0 ) then
                        local p_obj = g_sim:object( o_pid )
                        if p_obj then
                            if p_g_vert and game_graph():valid_vertex_id( p_g_vert ) then
                                --if p_o_sect=="inventory_box" and box_is_protected(p_obj)==true then
                                if
                                       p_o_sect == "inventory_box"
                                    or p_o_sect == "m_inventory_box"
                                    or p_o_sect == "rucksack"
                                    or box_is_protected( p_obj ) == true
                                then
                                    map = ""
                                else
                                    local p_map = g_sim:level_name( game_graph():vertex( p_g_vert ):level_id() )
                                    if p_map ~= map then
                                        if not off_npcs[ p_map ] then
                                            off_npcs[ p_map ] = {
                                                monsters  = {},
                                                stalkers  = {},
                                                weapons   = {},
                                                artefacts = {},
                                                inv_boxes = {}
                                            }
                                        end
                                        map = p_map
                                    end 
                                end
                            end
                        end
                    end
                    if map ~= "" then
                        table.insert( off_npcs[ map ].weapons, { id = o_id, name = o_name } )
                    end
                end
            elseif strpos( o_sect, "^af_" ) then
                if o_pid ~= nil and o_pid ~= BAD_OBJ_ID and o_pid ~= 0 then
                    local p_obj = g_sim:object( o_pid )
                    if p_obj then
                        if p_g_vert and game_graph():valid_vertex_id( p_g_vert ) then
                            --if p_o_sect=="inventory_box" and box_is_protected(p_obj)==true then
                            if
                                   p_o_sect == "inventory_box"
                                or p_o_sect == "m_inventory_box"
                                or p_o_sect == "rucksack"
                                or box_is_protected( p_obj ) == true
                            then
                                map = ""
                            else
                                local p_map = g_sim:level_name( game_graph():vertex( p_g_vert ):level_id() )
                                if p_map ~= map then
                                    if not off_npcs[ p_map ] then
                                        off_npcs[ p_map ] = {
                                            monsters  = {},
                                            stalkers  = {},
                                            weapons   = {},
                                            artefacts = {},
                                            inv_boxes = {}
                                        }
                                    end
                                    map = p_map
                                end 
                            end
                        end
                    end
                end
                if map ~= "" then
                    table.insert( off_npcs[ map ].artefacts, { id = o_id, name = o_name } )
                end
            end
            if (
                    o_pid ~= nil
                and o_pid ~= BAD_OBJ_ID
                and o_pid ~= 0
                and ( o_sid == nil or o_sid == NONE_SID or o_sid == NONE_CL_SID )
                and IsMonster( obj ) == false
                and IsStalker( obj ) == false
                )
            then
                local zz = g_sim:object( o_pid )
                if zz then
                    if
                        IsStalker( zz )
                        and (
                                   zz.m_story_id == nil
                                or zz.m_story_id == NONE_SID
                                or zz.m_story_id == NONE_CL_SID
                            )
                    then
                        if not items[ o_pid ] then items[ o_pid ] = {} end
                        table.insert( items[ o_pid ], { id = o_id, name = o_name } )
                        gps_habar.insert_item( o_pid, obj )
                    else
                        if not items[ o_pid ] then items[ o_pid ] = {} end
                        table.insert( items[ o_pid ], { id = o_id, name = o_name } )
                        gps_habar.insert_item( o_pid, obj )
                    end
                end
            end
        end
    end
end

function build_tables()
    rel_enemy         = utils.cfg_get_number( sini, "game_relations", "goodwill_enemy",  nil, false, -1000  )
    rel_friend        = utils.cfg_get_number( sini, "game_relations", "goodwill_friend", nil, false, 1000   )
    local s_comm_list = utils.cfg_get_string( sini, "game_relations", "communities",     nil, false, "", "" )
    local comm_list   = {}
    local s_value     = amk.str_explode( ",", amk.trim( s_comm_list ), true )
    for i = 1, #s_value, 2 do
        local s_comm = s_value[ i ]
        table.insert( comm_list, s_comm )
    end
    local tmp = {}
    local result, id, value = nil, nil, nil
    for i = 0, sini:line_count( "communities_relations" ) - 1 do
        result, id, value = sini:r_line( "communities_relations", i, "", "" )
        if id ~= nil and trim( id ) ~= nil and trim( id ) ~= "" then
            relation_matrix[ trim( id ) ] = {}
            table.insert( tmp, trim( id ) )
        end
    end
    for i = 1, #tmp do
        local value   = utils.cfg_get_string( sini, "communities_relations", tmp[ i ], nil, false, "", "" )
        local idx     = tmp[ i ]
        local m_value = amk.str_explode( ",", trim( value ), true )
        for j = 1, #m_value do
            local idx2 = comm_list[ j ]
            local v    = m_value[ j ]
            if relation_matrix[ idx ] and idx2 ~= nil and v ~= nil then
                relation_matrix[ idx ][ idx2 ] = tonumber( trim( v ) )
            end
        end
    end
    sell_table = {}
    sini       = ini_trade_generic
    local cfg_sell = utils.cfg_get_string( sini, "trader", "sell_condition", npc, false, false, "" )
    if sini and sini:section_exist( cfg_sell ) then
        local result, id, value = nil, nil, nil
        for a = 0, sini:line_count( cfg_sell ) - 1 do
            result, id, value = sini:r_line( cfg_sell, a, "", "" )
            if
                id ~= nil
                and amk.trim( id ) ~= ""
                and amk.trim( id ) ~= nil
                and amk.trim( value ) ~= ""
                and amk.trim( value ) ~= nil
            then
                -- Добавим в таблицу, что можно продавать.
                sell_table[ id ] = true
            end
        end
    end
    local death_ini = ini_death_generic
        --' Заполняем таблицу зависимостей
    item_dependence = {}
    local n = death_ini:line_count( "item_dependence" )
    local id, value = "", ""
    for i = 0, n - 1 do
        result, id, value     = death_ini:r_line( "item_dependence", i, "", "" )
        item_dependence[ id ] = {}
        local vvv = parse_names( value )
        for k, v in pairs( vvv ) do
            item_dependence[ id ][ v ] = true
        end
    end
    --' Предметы, которые нельзя продавать(квестовые например)
    always_keep_item = {}
    local n = death_ini:line_count( "keep_items" )
    for i = 0, n - 1 do
        result, id, value = death_ini:r_line( "keep_items", i, "", "" )
        if value == "true" then always_keep_item[ id ] = true end
    end
    tables_ready = true
end

function update_npc_tables()
    off_npcs = {} 
    local obj
    local ids, cnt = registry.all_objects( true )
    for n = 1, cnt do
        local id = ids[ n ]
        obj = g_sim:object( id )
        if obj then add_fresh_meat( obj ) end
    end
    checked_marked_npc()
    check_be_enemies()
    check_item_owners()
    check_trapped_bodies()
end

function update_trade()
    for a = 1, MAX_OBJ_ID do
        obj = g_sim:object( a )
        if obj then process_trade( obj ) end
    end
end

function update_tables( level )
    off_npcs[ level ] = {
        monsters  = {},
        stalkers  = {},
        weapons   = {},
        artefacts = {},
        inv_boxes = {}
     }
    local obj
    for a = 1, MAX_OBJ_ID do
        obj = g_sim:object( a )
        if (
            obj
            and g_sim:level_name( game_graph():vertex( obj.m_game_vertex_id ):level_id() ) == level
            )
        then
            add_fresh_meat( obj )
        elseif ( obj and obj.parent_id ~= nil ) then
            local p_obj = g_sim:object( obj.parent_id )
            if p_obj then
                local p_map = g_sim:level_name( game_graph():vertex( p_obj.m_game_vertex_id ):level_id() )
                if p_map == level then add_fresh_meat( obj ) end
            end
        end
    end 
end

function trim( s )
    return( string.gsub( s, "^%s*(.-)%s*$", "%1" ) )
end

function offline_alife( level_name )
    local lname
    if level_name then
        lname = level_name
    else
        lname = maps[ lua_random( #maps ) ]
    end 
    local st = 0
    if off_npcs[ lname ] then st = #off_npcs[ lname ].stalkers end
    if st > 0 then
        for search = 1, search_intensivity do
            local rnd = lua_random( st )
            if off_npcs[ lname ].stalkers[ rnd ] then 
                local victim = g_sim:object( off_npcs[ lname ].stalkers[ rnd ].id )
                if
                    victim
                    and not victim.online
                    and victim.health
                    and victim.can_switch_online
                    and victim:health() > health_wound_set
                    and victim:can_switch_online()
                    and victim:name() == off_npcs[ lname ].stalkers[ rnd ].name
                then
                    local vdata = collect_info( victim, lname )
                    if #vdata.inv_boxes > 0 then
                        on_inv_boxes_found( victim, vdata )
                        break
                    elseif #vdata.weapons.seen > 0 then
                        on_weapons_found( victim, vdata )
                        break
                    elseif #vdata.artefacts > 0 then
                        on_artifacts_found( victim, vdata )
                        break
                    elseif items[ victim.id ] and #items[ victim.id ] > 0 then
                        process_trade( victim, vdata )
                        break
                    elseif #vdata.monsters > 0 then
                        on_monsters_found( victim, vdata )
                        break
                    elseif #vdata.corpses.stalkers > 0 then
                        on_npc_corpses_found( victim, vdata )
                        break
                    elseif #vdata.corpses.monsters > 0 then
                        on_monster_corpses_found( victim, vdata )
                        break
                    elseif #vdata.enemies > 0 then
                        on_enemies_found( victim, vdata )
                        break
                    else
                        --amk.mylog("__")
                    end
                end
            end
        end
    end
end

function collect_info( victim, map )
    local vdata      = {}
    vdata.rank       = victim:rank()
    vdata.health     = victim:health()
    vdata.community  = victim:community()
    local wp         = #off_npcs[ map ].weapons
    vdata.fire_power = 0
    vdata.weapons    = { own = {},seen = {} }
    if wp > 0 then
        for w = 1, wp do
            if off_npcs[ map ].weapons[ w ] then
                local www = g_sim:object( off_npcs[ map ].weapons[ w ].id )
                if www and www:name() == off_npcs[ map ].weapons[ w ].name then
                    if www.parent_id == victim.id then
                        table.insert( vdata.weapons.own, { id = www.id, name = www:name() } )
                        local fp = get_weapon_firepower( www )
                        if vdata.fire_power < fp then vdata.fire_power = fp end
                    elseif
                        www:can_switch_online()
                        and victim.position:distance_to( www.position ) < look_radius
                        and sobj_is_far( www, to_actor )
                    then
                        if
                               www.parent_id == nil
                            or www.parent_id == BAD_OBJ_ID
                            or (
                                g_sim:object( www.parent_id )
                                and g_sim:object( www.parent_id ):section_name() == "inventory_box"
                                )
                        then
                            table.insert( vdata.weapons.seen, { id = www.id, name = www:name() } )
                        end
                    end
                end
            end
        end
    end
    local npc_peaceful = npc_smart_is_peaceful( victim )
    vdata.friends = {}
    vdata.enemies = {}
    vdata.corpses = { monsters = {},stalkers = {} }
    if #off_npcs[ map ].stalkers > 0 then
        for a, z in pairs( off_npcs[ map ].stalkers ) do
            if off_npcs[ map ].stalkers[ a ] then
                local opponent = g_sim:object( off_npcs[ map ].stalkers[ a ].id )
                if
                        opponent
                    and opponent.id ~= victim.id
                    and opponent.health
                    and opponent.can_switch_online
                    and opponent:can_switch_online()
                    and opponent:name() == off_npcs[ map ].stalkers[ a ].name
                then
                    if victim.position:distance_to( opponent.position ) < look_radius then
                        if opponent:health() > 0 then
                            local rel = relation_check( victim, opponent )
                            if rel >= rel_friend then
                                table.insert( vdata.friends, { id = opponent.id, name = opponent:name() } )
                            elseif rel <= rel_enemy then
                                if npc_peaceful == false and npc_smart_is_peaceful( opponent ) == false then
                                    table.insert( vdata.enemies, { id = opponent.id, name = opponent:name() } )
                                end
                            end
                        else
                            if sobj_is_far( opponent, to_actor ) then
                                table.insert( vdata.corpses.stalkers, { id = opponent.id, name = opponent:name() } )
                            end
                        end
                    end
                end
            end
        end
    end
    vdata.monsters = {}
    if off_npcs[ map ].monsters then
        if #off_npcs[ map ].monsters > 0 then
            for a, z in pairs( off_npcs[ map ].monsters ) do
                if off_npcs[ map ].monsters[ a ] then
                    local monster = g_sim:object( off_npcs[ map ].monsters[ a ].id )
                    if
                        can_be_online( monster )
                        and monster.health
                        and monster:name() == off_npcs[ map ].monsters[ a ].name
                        and victim.position:distance_to( monster.position ) < look_radius
                    then
                        if monster:health() > 0 then
                            table.insert( vdata.monsters, { id = monster.id, name = monster:name() } )
                        else
                            if sobj_is_far( monster, to_actor ) then
                                table.insert( vdata.corpses.monsters, { id = monster.id, name = monster:name() } )
                            end
                        end
                    end
                end
            end
        end
    end
    vdata.artefacts = {}
    if off_npcs[ map ].artefacts then
        if #off_npcs[ map ].artefacts > 0 then
            for a, z in pairs( off_npcs[ map ].artefacts ) do
                if off_npcs[ map ].artefacts[ a ] then
                    local artefact = g_sim:object( off_npcs[ map ].artefacts[ a ].id )
                    if (
                            artefact
                        and artefact.can_switch_online
                        and artefact:can_switch_online()
                        and artefact:name() == off_npcs[ map ].artefacts[ a ].name
                        and victim.position:distance_to( artefact.position ) < look_radius
                        and sobj_is_far( artefact, to_actor )
                        )
                    then
                        if
                               artefact.parent_id == nil
                            or artefact.parent_id == BAD_OBJ_ID
                            or (
                                g_sim:object( artefact.parent_id )
                                and ( g_sim:object( artefact.parent_id ):section_name() == "inventory_box" )
                                )
                        then
                            table.insert( vdata.artefacts, { id = artefact.id, name = artefact:name() } )
                        end
                    end
                end
            end
        end
    end
    vdata.inv_boxes     = {}
    vdata.hide_boxes    = {}
    local allemptyboxes = {}
    if off_npcs[ map ].inv_boxes then
        if #off_npcs[ map ].inv_boxes > 0 then
            for a, z in pairs( off_npcs[ map ].inv_boxes ) do
                if off_npcs[ map ].inv_boxes[ a ] then
                    local inv_box = g_sim:object( off_npcs[ map ].inv_boxes[ a ].id )
                    if (
                            inv_box
                        and inv_box.can_switch_online
                        and inv_box:can_switch_online()
                        and inv_box:name() == off_npcs[ map ].inv_boxes[ a ].name
                        and ( inv_box.parent_id == nil or inv_box.parent_id == BAD_OBJ_ID )
                        )
                        and sobj_is_far( inv_box, to_actor )
                    then
                        local dist      = victim.position:distance_to( inv_box.position )
                        local owner_id  = get_box_owner( inv_box.id )
                        local lookr     = look_radius_box
                        local is_ruksak = inv_box:section_name() == "m_inventory_box" or inv_box:section_name() == "rucksack"
                        if is_ruksak then lookr = look_radius_ruksak end
                        if
                            dist <= lookr
                            and ( owner_id == BAD_OBJ_ID or owner_id == nil )
                        then    --200 м для рюкзака, 100 м для других нычек(не собственных неписей).
                            --local zdist = dist/lookr*0.1
                            --if my_lua_random() > zdist then
                            table.insert( vdata.inv_boxes, { id = inv_box.id, name = inv_box:name() } )
                            --end
                        end
                        --making the list of empty boxes to hide habar except ruksaks
                        if
                            not is_ruksak
                            and (
                                    not items[ inv_box.id ]
                                    or #items[ inv_box.id ] == 0
                                    or owner_id ~= BAD_OBJ_ID
                                )
                        then 
                            table.insert( allemptyboxes, inv_box )    
                            if dist <= look_radius_hide1 then -- 30 метров всего
                                table.insert( vdata.hide_boxes, { id = inv_box.id, name = inv_box:name() } )
                            end
                        end
                        
                    end
                end
            end
            if #vdata.hide_boxes == 0 then
                for a, z in pairs( allemptyboxes ) do
                    local inv_box = allemptyboxes[ a ]
                    if victim.position:distance_to( inv_box.position ) <= look_radius_hide2 then
                        table.insert( vdata.hide_boxes, { id = inv_box.id, name = inv_box:name() } )
                    end
                end
            end
        end
    end
    return vdata
end

function relation_check( victim, opponent )
    if
            relation_matrix[ opponent:community() ]
        and relation_matrix[ opponent:community() ][ victim:community() ]
    then
        return relation_matrix[ opponent:community() ][ victim:community() ]
    else
        return 0
    end
end

function on_enemies_found( victim, vdata )
    if victim == nil or vdata == nil then return end
    local obj, v_obj
    local team_A    = {}
    local team_B    = {}
    local wpn       = get_npc_weapon( victim )
    local rank      = victim:rank()
    local health    = victim:health()
    local firepower = get_weapon_firepower( wpn )
    local player    = {
                            player    = victim, 
                            weapon    = wpn, 
                            rank      = rank, 
                            health    = health, 
                            firepower = firepower, 
                            flags     = get_flags( victim.id )
                       }
    table.insert( team_A, player )
    if vdata.friends and #vdata.friends > 0 then
        for i, z in pairs( vdata.friends ) do
            v_obj = vdata.friends[ i ]
            if v_obj then
                obj = g_sim:object( v_obj.id )
                if obj and obj:name() == v_obj.name then
                    wpn       = get_npc_weapon( obj )
                    rank      = obj:rank()
                    health    = obj:health()
                    firepower = get_weapon_firepower( wpn )
                    player    = {
                                    player    = obj,
                                    weapon    = wpn,
                                    rank      = rank,
                                    health    = health,
                                    firepower = firepower,
                                    flags     = get_flags( obj.id )
                                }
                    table.insert( team_A, player )
                end
            end
        end
    end
    for i, z in pairs( vdata.enemies ) do
        v_obj = vdata.enemies[ i ]
        obj   = g_sim:object(v_obj.id)
        if obj and obj:name() == v_obj.name then
            wpn = get_npc_weapon( obj )
            if wpn == nil then list_npc_items( obj ) end
            rank      = obj:rank()
            health    = obj:health()
            firepower = get_weapon_firepower( wpn )
            player    = {
                            player    = obj,
                            weapon    = wpn,
                            rank      = rank,
                            health    = health,
                            firepower = firepower,
                            flags     = get_flags( obj.id )
                        }
            table.insert( team_B, player )
        end
    end
    local distances = {}
    for a = 1, #team_A do
        local from = team_A[ a ].player
        distances[ from.id ] = {}
        for b = 1, #team_B do
            local to = team_B[ b ].player
            distances[ to.id ] = {}
            if ( from and to and from.id and to.id ) then
                local dist = math.floor( from.position:distance_to( to.position ) )
                local fp_A = math.floor( team_A[ a ].firepower / ( dist / dist_coeff ) )
                local fp_B = math.floor( team_B[ b ].firepower / ( dist / dist_coeff ) )
                local item = { distance = dist, fpA = fp_A, fpB = fp_B }
                distances[ from.id ][ to.id ] = { distance = dist, fp = fp_A }
                distances[ to.id ][ from.id ] = { distance = dist, fp = fp_B }
            end
        end
    end
    table.sort( team_A, function( a, b ) return a.rank > b.rank end )
    table.sort( team_B, function( a, b ) return a.rank > b.rank end )
    local size_A, size_B = #team_A, #team_B
    local died_A, died_B = 0, 0
    for i = 1, max_rounds do
        if ( #team_A >0 and #team_B > 0 ) then
            local index = #team_A
            local attacker, defender, attack_info, rank_hit_chance, distance_hit_chance, hit_chance
            if #team_B > index then index = #team_B end
            for j = 1, index do
                attacker = team_A[ j ]
                defender = team_B[ lua_random( #team_B ) ]
                if (
                    attacker
                    and defender
                    and attacker.player
                    and defender.player
                    and attacker.health > 0
                    and defender.health > 0
                    and distances[ attacker.player.id ][ defender.player.id ]
                    )
                then
                    attack_info         = distances[ attacker.player.id ][ defender.player.id ]
                    rank_hit_chance     = math.floor( ( attacker.rank - defender.rank) / 50 )
                    distance_hit_chance = 100 - math.floor( ( attack_info.distance ) / 1.5 )                    
                    hit_chance = distance_hit_chance + rank_hit_chance
                    if ( ( lua_random() * 100 ) < hit_chance ) then
                        if attack_info.fp >= base_fp then
                            defender.health = 0
                        else
                            defender.health = defender.health - ( attack_info.fp / base_fp )
                            if defender.health < 0 then defender.health = 0 end                           
                        end
                        if defender.health <= 0 then
                            if defender.flags >= 2 then
                                defender.health = health_wound
                            else
                                if IsStalker( attacker.player ) and attacker.player.community then
                                    local m_comm = attacker.player:community()
                                    if
                                           m_comm == "stalker"
                                        or m_comm == "dolg"
                                        or m_comm == "freedom"
                                        or m_comm == "green"
                                    then
                                        local coeff = 1
                                        if ( defender.rank < attacker.rank ) then coeff = 0.5 end
                                        if ( defender.rank > attacker.rank ) then coeff = 2   end
                                        attacker.player:set_rank( attacker.player:rank() + math.floor( rate_kill_base*coeff ) )
                                    end
                                end
                                news_main.on_offline_death( defender.player, attacker.player, attacker.weapon )
                                local itA, v_itA, l_objA
                                if
                                    items[ defender.player.id ]
                                    and #items[ defender.player.id ] > 0
                                then
                                    for a = 1, #items[ defender.player.id ] do
                                        v_itA = items[ defender.player.id ][ a ]
                                        if v_itA then
                                            itA = g_sim:object( v_itA.id )
                                            if
                                                itA
                                                and itA:name() == v_itA.name
                                                and itA.parent_id == defender.player.id
                                            then
                                                l_objA = pick_item( attacker.player, itA )
                                            else
                                                if itA then
                                                    local mm = itA.parent_id
                                                    if mm == nil then mm = "nil" end
                                                end
                                            end 
                                        end
                                    end
                                end
                                if vdata then
                                    local rnd = my_lua_random( 100 )
                                    if rnd >= 85 then
                                        npc_hide_habar_boxs( attacker.player, vdata.hide_boxes )
                                    else
                                        process_trade( attacker.player, vdata )
                                    end
                                end 
                            end
                        end
                    else
                    end
                end
                if (team_B[j]~=nil) then
                    attacker = team_B[j]
                    defender = team_A[lua_random(#team_A)]
                    if (attacker and defender and attacker.player and defender.player and attacker.health>0 and defender.health>0 and distances[attacker.player.id][defender.player.id]) then
                        attack_info = distances[attacker.player.id][defender.player.id]
                        rank_hit_chance = math.floor((attacker.rank - defender.rank) / 50)
                        distance_hit_chance = 100 - math.floor((attack_info.distance) / 1.5)                    
                        hit_chance = distance_hit_chance + rank_hit_chance
                        if lua_random()*100 < hit_chance then
                            if attack_info.fp >= base_fp then
                                defender.health = 0
                            else
                                defender.health = defender.health -(attack_info.fp / base_fp)
                                if (defender.health < 0) then defender.health = 0 end
                            end
                            if (defender.health <= 0) then
                                if (defender.flags >= 2) then
                                    defender.health = health_wound
                                else                                
                                    if (IsStalker(attacker.player) and attacker.player.community) then
                                        local m_comm    = attacker.player:community()
                                        if (m_comm=="stalker" or m_comm=="dolg" or m_comm=="freedom" or m_comm=="green") then
                                            local coeff = 1
                                            if (defender.rank < attacker.rank) then coeff = 0.5 end
                                            if (defender.rank > attacker.rank) then coeff = 2 end
                                            attacker.player:set_rank(attacker.player:rank() + math.floor(rate_kill_base*coeff))                         
                                        end
                                    end
                                    news_main.on_offline_death(defender.player, attacker.player, attacker.weapon)
                                    local itB, v_itB
                                    local l_objB
                                    if (items[defender.player.id] and #items[defender.player.id] > 0) then
                                        for a=1,#items[defender.player.id] do
                                            v_itB = items[defender.player.id][a]
                                            if (v_itB) then
                                                itB = g_sim:object(v_itB.id)
                                                if (itB and itB:name()==v_itB.name and itB.parent_id==defender.player.id) then
                                                    l_objB = pick_item(attacker.player, itB)
                                                else
                                                    if (itB) then
                                                        local mm = itB.parent_id
                                                        if mm==nil then mm = "nil" end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                    if vdata then
                                        local rnd = my_lua_random(100)
                                        if rnd >= 85 then
                                            npc_hide_habar_boxs(attacker.player, vdata.hide_boxes)
                                        else
                                            process_trade(attacker.player, vdata)
                                        end
                                    end 
                                end
                            end

                        else

                        end
                    end
                end
            end
        else
            break
        end
        for kk, vv in pairs(team_A) do
            if (vv.health <=0) then
                set_npc_health(vv.player, 0)
                team_A[kk]=nil
                died_A = died_A + 1
            elseif (vv.health <= health_wound and vv.health > 0) then
                set_npc_health(vv.player, health_wound_set)
                news_main.on_offline_wound(vv.player)
                team_A[kk]=nil
            end
        end
        for kk, vv in pairs(team_B) do
            if (vv.health <=0) then
                set_npc_health(vv.player, 0)
                team_B[kk]=nil
                died_B = died_B + 1
            elseif (vv.health <= health_wound and vv.health > 0) then
                set_npc_health(vv.player, health_wound_set)
                news_main.on_offline_wound(vv.player)
                team_B[kk]=nil
            end
        end     
    end
end

function on_monsters_found(victim, vdata)
    if (victim==nil or vdata==nil) then return end
    local obj, v_obj
    local team_A = {}
    local team_B = {}
    local wpn = get_npc_weapon(victim)
    local rank = victim:rank()
    local health = victim:health()
    local firepower = get_weapon_firepower(wpn)
    local player = {player = victim, weapon = wpn, rank = rank, health = health, firepower = firepower, flags = get_flags(victim.id)}
    table.insert(team_A, player)
    if (vdata.friends and #vdata.friends > 0) then
        for i,v in pairs(vdata.friends) do
            v_obj = vdata.friends[i]
            obj = g_sim:object(v_obj.id)
            if (obj and obj:name()==v_obj.name) then
                wpn = get_npc_weapon(obj)
                rank = obj:rank()
                health = obj:health()
                firepower = get_weapon_firepower(wpn)
                player = {player = obj, weapon = wpn, rank = rank, health = health, firepower = firepower, flags = get_flags(obj.id)}
                table.insert(team_A, player)
            end
        end
    end
    local params
    for i,v in pairs(vdata.monsters) do
        v_obj = vdata.monsters[i]
        obj = g_sim:object(v_obj.id)
        if (obj and obj:name()==v_obj.name) then
            params = get_monster_params(obj)
            if (params) then
                rank = obj:rank()
                health = obj:health()
                firepower = params.attack*base_fp
                player = {player = obj, speed = params.speed, attack_dist = params.dist, immunity = params.immunity, rank = rank, health = health, firepower = firepower, flags = get_flags(obj.id) }
                table.insert(team_B, player)
            else
            end
        end
    end
    local distances = {}
    for a=1, #team_A do
        local from = team_A[a].player
        distances[from.id] = {}
        for b=1, #team_B do
            local to = team_B[b].player
            distances[to.id] = {}
            if (from and to and from.id and to.id) then
                local dist = math.floor(from.position:distance_to(to.position))
                local fp_A = math.floor(team_A[a].firepower /(dist / dist_coeff))
                local fp_B = math.floor(team_B[b].firepower)
                local item = {distance = dist, fpA = fp_A, fpB = fp_B}
                distances[from.id][to.id] = {distance = dist, fp = fp_A}
                distances[to.id][from.id] = {distance = dist, fp = fp_B}
            end
        end
    end
    table.sort(team_A, function(a,b) return a.rank > b.rank end)
    table.sort(team_B, function(a,b) return a.rank > b.rank end)
    local size_A = #team_A
    local size_B = #team_B
    local died_A = 0
    local died_B = 0
    for i=1, max_rounds do
        if (#team_A >0 and #team_B > 0) then
            local index = #team_A
            local attacker
            local defender
            local attack_info
            local rank_hit_chance
            local distance_hit_chance
            local hit_chance
            if (#team_B > index) then index = #team_B end
            for j = 1, index do
                attacker = team_A[j]
                defender = team_B[lua_random(#team_B)]
                if (attacker and defender and attacker.player and defender.player and attacker.health>0 and defender.health>0 and distances[attacker.player.id][defender.player.id]) then
                    attack_info = distances[attacker.player.id][defender.player.id]
                    rank_hit_chance = math.floor((attacker.rank - defender.rank) / 50)
                    local dii = math.floor(attack_info.distance - defender.speed*i*5)
                    if (dii <=8) then dii = 45 end
                    distance_hit_chance = 100 - math.floor(dii / 1.5)                   
                    hit_chance = distance_hit_chance + rank_hit_chance
                    if ((lua_random()*100) < hit_chance) then
                        if (math.floor(attack_info.fp*defender.immunity) >= base_fp) then
                            defender.health = 0
                        else
                            defender.health = defender.health -(attack_info.fp / base_fp)*defender.immunity
                            if (defender.health < 0) then defender.health = 0 end                           
                        end
                        if (defender.health <= 0) then
                            if defender.flags >= 2 then
                                defender.health = health_wound
                            else
                                if (IsStalker(attacker.player) and attacker.player.community) then
                                    local m_comm    = attacker.player:community()
                                    if (m_comm=="stalker" or m_comm=="dolg" or m_comm=="freedom" or m_comm=="green") then
                                        local coeff = 1
                                        if (defender.rank < attacker.rank) then coeff = 0.5 end
                                        if (defender.rank > attacker.rank) then coeff = 2 end
                                        attacker.player:set_rank(attacker.player:rank() + math.floor(rate_kill_base*coeff))
                                    end
                                end
                                news_main.on_offline_death(defender.player, attacker.player, attacker.weapon)
                                local itA, v_itA
                                local l_objA
                                if (items[defender.player.id] and #items[defender.player.id] > 0) then
                                    for a=1,#items[defender.player.id] do
                                        v_itA = items[defender.player.id][a]
                                        if (v_itA) then
                                            itA = g_sim:object(v_itA.id)
                                            if (itA and itA:name()==v_itA.name and itA.parent_id==defender.player.id) then
                                                l_objA = pick_item(attacker.player, itA)
                                            else
                                                if (itA) then
                                                    local mm = itA.parent_id
                                                    if mm==nil then mm = "nil" end
                                                end                                         
                                            end         
                                        end
                                    end
                                end
                                
                                if vdata then
                                    local rnd = my_lua_random(100)
                                    if rnd >= 85 then
                                        npc_hide_habar_boxs(attacker.player, vdata.hide_boxes)
                                    else
                                        process_trade(attacker.player, vdata)
                                    end
                                end 
                            end
                        end
                    else
                    end
                end
                if (team_B[j]~=nil) then
                    attacker = team_B[j]
                    defender = team_A[lua_random(#team_A)]
                    if (attacker and defender and attacker.player and defender.player and attacker.health>0 and defender.health>0 and distances[attacker.player.id][defender.player.id]) then
                        attack_info = distances[attacker.player.id][defender.player.id]
                        if (attack_info.distance - attacker.speed*i*5 < attacker.attack_dist) then
                            rank_hit_chance = math.floor((attacker.rank - defender.rank) / 50)
                            distance_hit_chance = 100
                            hit_chance = distance_hit_chance + rank_hit_chance
                            if lua_random()*100 < hit_chance then
                                if attack_info.fp >= base_fp then
                                    defender.health = 0
                                else
                                    defender.health = defender.health -(attack_info.fp / base_fp)
                                    if (defender.health < 0) then defender.health = 0 end
                                end
                                if (defender.health==0) then
                                    if defender.flags >= 2 then
                                        defender.health = health_wound
                                    else
                                        local coeff = 1
                                        if (defender.rank < attacker.rank) then coeff = 0.5 end
                                        if (defender.rank > attacker.rank) then coeff = 2 end
                                        news_main.on_offline_death(defender.player, attacker.player, nil)
                                    end
                                end
                            else
                            end
                        else
                        end
                    end
                end
            end
        else
            break
        end
        for kk, vv in pairs(team_A) do
            if (vv.health <=0) then
                set_npc_health(vv.player, 0)
                team_A[kk]=nil
                died_A = died_A + 1
            elseif (vv.health <= health_wound and vv.health > 0) then
                set_npc_health(vv.player, health_wound_set)
                news_main.on_offline_wound(vv.player)
                team_A[kk]=nil
            end
        end
        for kk, vv in pairs(team_B) do
            if (vv.health <=0) then
                set_npc_health(vv.player, 0)
                team_B[kk]=nil
                died_B = died_B + 1
            elseif (vv.health <= health_wound and vv.health > 0) then
                set_npc_health(vv.player, health_wound_set)
                news_main.on_offline_wound(vv.player)
                team_B[kk]=nil
            end
        end     
    end 
end

function on_npc_corpses_found(victim, vdata)
    if (victim==nil or vdata==nil) then return end
    if (vdata.corpses==nil) then return end
    if (vdata.corpses.stalkers==nil) then return end
    local obj, v_obj
    local id
    local v_id = victim.id
    for i=1, #vdata.corpses.stalkers do
        v_obj = vdata.corpses.stalkers[i]
        local corpse = g_sim:object(v_obj.id)
        if (corpse and corpse:name()==v_obj.name) then
            news_main.on_offline_corpse_found(victim, corpse)
            id = corpse.id
            if (id and items[id]) then
                local anypick = false
                for a=1, #items[id] do
                    local v_itA = items[id][a]
                    if (v_itA) then
                        local itA = g_sim:object(v_itA.id)
                        if (itA and itA:name()==v_itA.name and itA.parent_id==id) then
                            local l_objA = pick_item(victim, itA)
                            if l_objA then
                                anypick = true
                            end
                        end         
                    end
                end
                if anypick then
                    set_body_trap(victim.id, id)
                end
            end
        end
    end
    if vdata then
        local rnd = my_lua_random(100)
        if rnd >= 85 then
            npc_hide_habar_boxs(victim, vdata.hide_boxes)
        else
            process_trade(victim, vdata)
        end
    end 
end

function on_monster_corpses_found(victim, vdata)
    if (victim==nil or vdata==nil) then return end
    if (vdata.corpses==nil) then return end
    if (vdata.corpses.monsters==nil) then return end
    local obj, v_obj
    local object
    local id
    local v_id = victim.id
    for i=1, #vdata.corpses.monsters do
        v_obj = vdata.corpses.monsters[i]
        local corpse = g_sim:object(v_obj.id)
        if (corpse and corpse:name()==v_obj.name) then
            news_main.on_offline_corpse_found(victim, corpse)       
            id = corpse.id
            if (id and items[id]) then
                for a=1, #items[id] do
                    local v_itA = items[id][a]
                    if (v_itA) then
                        local itA = g_sim:object(v_itA.id)
                        if (itA and itA:name()==v_itA.name and itA.parent_id==id) then
                            local l_objA = pick_item(victim, itA)
                        end         
                    end
                end
            end
        end
    end
    if vdata then
        local rnd = my_lua_random(100)
        if rnd >= 85 then
            npc_hide_habar_boxs(victim, vdata.hide_boxes)
        else
            process_trade(victim, vdata)
        end
    end 
end

function on_weapons_found(victim, vdata)
    if (victim==nil or vdata==nil) then return end
    local obj, v_obj
    local object
    local v_id = victim.id
    for i=1, #vdata.weapons.seen do
        v_obj = vdata.weapons.seen[i]
        if (v_obj) then
            object = g_sim:object(v_obj.id)
            if (object and object:name()==v_obj.name) then
                obj = pick_item(victim, object)
            end
        end
    end
    process_trade(victim, vdata)
end

function on_artifacts_found(victim, vdata)
    if (victim==nil or vdata==nil) then return end
    local obj, v_obj
    local object
    local v_id = victim.id
    local b_stalker = false
    if (IsStalker(victim) and victim.community) then
        local m_comm    = victim:community()
        if (m_comm=="stalker" or m_comm=="dolg" or m_comm=="freedom" or m_comm=="green") then
            b_stalker = true
        end
    end
    for i=1, #vdata.artefacts do
        v_obj = vdata.artefacts[i]
        if (v_obj) then
            object = g_sim:object(v_obj.id)
            if (object and object:name()==v_obj.name) then
                obj = pick_item(victim, object)
                if (obj) then
                    if (b_stalker==true) then
                        victim:set_rank(victim:rank() + rate_art_found)
                    end
                end
            end
        end
    end
    if vdata then
        local rnd = my_lua_random(100)
        if rnd >= 85 then
            npc_hide_habar_boxs(victim, vdata.hide_boxes)
        else
            process_trade(victim, vdata)
        end
    end 
end

function on_inv_boxes_found( victim, vdata )
    if ( victim == nil or vdata == nil ) then return end
    local obj, v_obj
    local object
    local v_id      = victim.id
    local b_stalker = false
    if IsStalker( victim ) and victim.community then
        local m_comm = victim:community()
        if ( m_comm == "stalker" or m_comm == "dolg" or m_comm == "freedom" or m_comm == "green" ) then
            b_stalker = true
        end
    end
    for i = 1, #vdata.inv_boxes do
        local anyfound = false
        v_obj = vdata.inv_boxes[ i ]
        if v_obj then
            object = g_sim:object( v_obj.id )
            if ( object and object:name() == v_obj.name ) then
                if items[ v_obj.id ] and #items[ v_obj.id ] > 0 then
                    local a = 1
                    local checktrap = true
                    while a <= #items[ v_obj.id ] do
                        local v_itA = items[ v_obj.id ][ a ]
                        if v_itA then
                            local itA = g_sim:object( v_itA.id )
                            if ( itA and itA:name() == v_itA.name and itA.parent_id == v_obj.id ) then
                                local bTake = is_valuable( itA )
                                if bTake then
                                    if checktrap then
                                        if check_box_trapped( victim, v_obj ) then 
                                            npc_hide_habar_boxs( victim, vdata.hide_boxes )
                                            return
                                        end
                                        checktrap = false
                                    end
                                    local oldsize = #items[ v_obj.id ]
                                    if pick_item( victim, itA ) then
                                        anyfound = true
                                        if oldsize > #items[ v_obj.id ] then
                                            a = a - 1
                                        end
                                    end
                                end
                            end         
                        end
                        a = a + 1
                    end                 
                    if anyfound then set_box_trapped( v_obj.id, 0 ) end
                end
            end
        end
        if ( b_stalker == true ) and anyfound then victim:set_rank( victim:rank() + rate_art_found ) end
    end
    if vdata then
        local rnd = my_lua_random( 100 )
        if rnd >= 85 then
            npc_hide_habar_boxs( victim, vdata.hide_boxes )
        else
            process_trade( victim, vdata )
        end
    end 
end

local nhideitems = {
    "device_torch",
    "device_pda",
    "hand_radio",
    "guitar_a",
    "harmonica_a",
    "binocular_a",
    "wpn_knife",
    "wpn_binoc",
    "bolt",
    "medkit_npc",
    "medkit_army",
    "medkit_scientic",
    "yad"
}

function my_log( mtext, oname )
    --amk.send_tip(oname, mtext,0,30,"gen_info")
    --get_console():execute("load ~~~~"..mtext.."   "..oname)
end

function check_hide_item( obj )
    if not obj then return false end
    local section = obj:section_name()
    if isWeapon( obj ) or is_ammo( obj ) or strpos( section, "_outfit", 1, true ) then return false end
    for iter = 1, #nhideitems do
        if section == nhideitems[ iter ] then return false end
    end
    return true
end

function is_ammo( obj )
    if obj and obj:clsid() == CLID_AMMO then return true
    else return false
    end
end

function isammofor( wpn, ammos )
    for aiter, ammo in pairs( ammos ) do
        local section_ammo = get_weapon_ammo( wpn )
        if strpos( section_ammo, ammo:section_name(), 1, true ) then
            return true
        end
    end
    return false
end

local max_ammo_boxes = 1

function npc_hide_habar_boxs( victim, boxs )
    if not boxs or not victim or not items[ victim.id ] then return end
    local nbox = #boxs
    if nbox == 0 then return end
    local box    = nil
    local nbvoxs = {}
    for iter = 1, nbox do
        local onwer_id = get_box_owner( boxs[ iter ].id )
        if onwer_id == victim.id then
            box = boxs[ iter ]
            break
        elseif
            ( onwer_id == BAD_OBJ_ID or onwer_id == nil )
            and not box_is_protected( boxs[ iter ] ) == true
        then
            table.insert( nbvoxs, boxs[ iter ] )
        end
    end
    if not box then
        local nb = #nbvoxs
        if nb > 0 then
            box = nbvoxs[ my_lua_random( nb ) ]
        else
            local mbox = nil
            local cnt  = 30000
            for iter = 1, nbox do
                mbox = boxs[ iter ]
                if items[ mbox.id ] then
                    if #items[ mbox.id ] < cnt then
                        cnt = #items[ mbox.id ]
                        box = mbox
                    end
                else
                    box = mbox
                    break
                end
            end
        end
    end
    if not box then return end
    local hitems   = {}
    local medkits  = {}
    local weapons  = {}
    local weapons1 = {}
    local weapons2 = {}
    local outfits  = {}
    local ammos    = {}
    for iter, zzz in pairs( items[ victim.id ] ) do
        local v_itA = items[ victim.id ][ iter ]
        if v_itA then
            local obj = g_sim:object( v_itA.id )
            if obj and obj:name() == v_itA.name and obj.parent_id == victim.id then
                local objsect = obj:section_name()
                if check_hide_item( obj ) then
                    table.insert( hitems, obj )
                elseif is_ammo( obj ) then
                    table.insert( ammos, obj )
                    anyhabar = true
                elseif strpos( objsect, "medkit", 1, true ) then
                    table.insert( medkits, obj )
                    anyhabar = true
                elseif strpos( objsect, "_outfit", 1, true ) then
                    anyhabar = true
                    table.insert( outfits, obj )
                elseif isWeapon( obj ) and strpos( objsect, "wpn_", 1, true ) then
                    local slot = get_weapon_slot( obj )
                    if slot == 1 or slot == 2 then
                        table.insert( weapons, obj )
                        anyhabar = true
                        if slot == 1 then
                            table.insert( weapons1, obj )
                        else
                            table.insert( weapons2, obj )
                        end
                    end
                end 
            end
        end
    end
    local boxobj = g_sim:object( box.id )
    if not boxobj then return end
    local habarcost    = hide_items_box( boxobj, hitems, 0, victim.id )
    local weaponparams = {}
    for witer, wpn in pairs( weapons ) do
        local fp = get_weapon_firepower( wpn )
        if isammofor( wpn, ammos ) then fp = fp * 1000 end
        weaponparams[ wpn.id ] = fp
    end
    table.sort( outfits,  function( a, b ) return get_item_cost( a )   < get_item_cost( b )   end )
    table.sort( weapons1, function( a, b ) return weaponparams[ a.id ] < weaponparams[ b.id ] end )
    table.sort( weapons2, function( a, b ) return weaponparams[ a.id ] < weaponparams[ b.id ] end )
    local coll_ammo = {}
    local aiter     = 1
    while aiter <= #ammos do
        local ammo     = ammos[ aiter ]
        local ammo_sec = ammo:section_name()
        if not coll_ammo[ ammo_sec ] then coll_ammo[ ammo_sec ] = 0 end
        local keep = false
        if coll_ammo[ ammo_sec ] < max_ammo_boxes then
            if #weapons1 > 0 then
                local wpn          = weapons1[ #weapons1 ]
                local section_ammo = get_weapon_ammo( wpn )
                if
                    section_ammo == ""
                    or strpos( section_ammo, ammo:section_name(), 1, true )
                then
                    coll_ammo[ ammo_sec ] = coll_ammo[ ammo_sec ] + 1
                    keep = true
                end
            end
            if not keep and #weapons2 > 0 then
                local wpn          = weapons2[ #weapons2 ]
                local section_ammo = get_weapon_ammo( wpn )
                if
                    section_ammo == ""
                    or strpos( section_ammo, ammo:section_name(), 1, true )
                then
                    coll_ammo[ ammo_sec ] = coll_ammo[ ammo_sec ] + 1
                    keep = true
                end
            end
        end
        if keep then
            --table.remove(ammos, aiter)
            ammos[ aiter ] = nil
        else
            aiter = aiter + 1
        end
    end
    habarcost = hide_items_box( boxobj, weapons1, 1, victim.id ) + habarcost
    habarcost = hide_items_box( boxobj, weapons2, 1, victim.id ) + habarcost
    habarcost = hide_items_box( boxobj, ammos,    0, victim.id ) + habarcost
    habarcost = hide_items_box( boxobj, medkits,  1, victim.id ) + habarcost
    habarcost = hide_items_box( boxobj, outfits,  1, victim.id ) + habarcost
    if habarcost > 0 then
        npc_put_trap_box( victim, box, habarcost )
        send_metka_hide_box( boxobj, victim )
        local owner_id = get_box_owner( box.id )
        if owner_id ~= BAD_OBJ_ID then
            local owner = g_sim:object( owner_id )
            if
                owner and IsStalker( owner )
                and owner.health and owner:health() > 0
            then
                if owner:rank() > victim:rank() then return end
            end
        end
        set_box_owner( box.id, victim.id )
    end
end

function IsTrader( npc_id )
    local npc = g_sim:object( npc_id )
    if not npc then return false end
    if npc:community() == "trader" then return true end
    if
        npc.smart_terrain_id
        and npc:smart_terrain_id()
        and npc:smart_terrain_id() ~= BAD_OBJ_ID
    then
        local sm = g_sim:object( npc:smart_terrain_id() )
        if
            sm and sm.gulag and sm.gulag.ltx
            and sm.gulag.ObjectJob and sm.gulag.Job
        then
            local jobid = sm.gulag.ObjectJob[ npc_id ]
            if jobid then
                local job = sm.gulag.Job[ jobid ]
                if
                    job and job.section
                    and sm.gulag.ltx:section_exist( job.section )
                    and sm.gulag.ltx:line_exist( job.section, "trade" )
                then
                    return true
                end
            end
        end
    end
    local char_ini = xr_logic.get_customdata_or_ini_file( npc, "<customdata>" )
    if
        char_ini and char_ini:section_exist( "logic" )
        and char_ini:line_exist( "logic", "trade" )
    then
        return true
    end
    return false
end

function find_metka_near_box( boxobj )
    if
        not boxobj
        or not game_graph():valid_vertex_id( boxobj.m_game_vertex_id )
    then
        return nil
    end
    local blid  = game_graph():vertex( boxobj.m_game_vertex_id ):level_id()
    local metka = nil
    for iter = 1, MAX_OBJ_ID do
        local obj = g_sim:object( iter )
        if
            obj and obj.parent_id and obj.parent_id == boxobj.id
            and obj.section_name and obj:section_name() == "amk_metka"
        then
            metka = obj
            break
        end
        if
            obj and ( obj.parent_id == nil or obj.parent_id == BAD_OBJ_ID )
            and obj.section_name and obj:section_name() == "amk_metka"
        then
            if game_graph():valid_vertex_id( obj.m_game_vertex_id ) then
                local mlid = game_graph():vertex( obj.m_game_vertex_id ):level_id()
                if blid == mlid and boxobj.position:distance_to( obj.position ) <= 2 then
                    metka = obj
                    break
                end
            end
        end
    end
    return metka
end

function send_metka_hide_box( boxobj, victim )
    local metka = find_metka_near_box( boxobj )
    if metka == nil then return end
    local npc = g_sim:object( victim.id )
    if not npc then return end
    local sname = get_npc_name( npc )
    for spot = 1, 4 do
        amk.remove_spot_from_map( boxobj.id, "crlc_big_treasure" .. spot )
    end
    local spot = lua_random( 1, 3 )
    amk.add_spot_on_map(
        boxobj.id, "crlc_big_treasure" .. spot, sname .. " cпрятал хабар в надежном месте"
    )
    if boxobj.m_story_id then
        local trman = treasure_manager.get_treasure_manager()
        if trman then
            local k = trman.treasure_by_target[ boxobj.m_story_id ]
            if k then 
                trman.treasure_info[ k ].active = true
                trman.treasure_info[ k ].done   = true
            end
        end
    end
    local pda_news = xr_sound.get_safe_sound_object( [[device\pda\pda_news]] )
    pda_news:play( db.actor, 0, sound_object.s2d )
    local task_texture, task_rect = get_texture_info( "ui_iconsTotal_found_thing" )
    local lname = news_main.get_level_name( news_main.get_object_levelname( boxobj ) )
    db.actor:give_game_news(
        lname .. ". " .. sname .. " спрятал хабар в надежном месте",
        task_texture, task_rect, 0, 5000
    )
end

function npc_put_trap_box( victim, box, habarcost )
    if habarcost < 1000 then return end
    local prob = 100
    if     habarcost < 5000  then prob = 5
    elseif habarcost < 10000 then prob = 15
    elseif habarcost < 20000 then prob = 25
    elseif habarcost < 30000 then prob = 35
    elseif habarcost < 50000 then prob = 45
    end
    if prob >= my_lua_random( 100 ) then
        local tr = get_box_trap_rank( box.id )
        if tr < victim:rank() then
            set_box_trapped( box.id, victim:rank() )
        end
    end
end

function hide_items_box( boxobj, itemlist, cntkeep, npc_id )
    local res = 0
    if #itemlist > cntkeep then
        for iter = 1, #itemlist - cntkeep do
            local obj = itemlist[ iter ]
            if obj and obj.id then
                if g_sim:object( obj.id ) == nil then return res end
                local section = g_sim:object( obj.id ):section_name()
                local new = create_newitem(
                    obj, boxobj.position, boxobj.m_level_vertex_id, boxobj.m_game_vertex_id, boxobj.id
                )
                if new then
                    res = res + get_item_cost( obj )
                    if new.parent_id then
                        if not items[ new.parent_id ] then items[ new.parent_id ] = {} end
                        table.insert( items[ new.parent_id ], { id = new.id, name = new:name() } )
                        gps_habar.insert_item( new.parent_id, new ) -- Idler++-- корректируем хабар в помеченных тайниках
                    end
                    set_item_owner( npc_id, new.id )
                    do_drop_object( obj )
                end 
            end
        end
    end
    return res
end

function check_box_trapped( victim, box )
    if victim == nil or box == nil then return false end
    local result = check_box_trap_trigger( victim, box )
    local boxobj = g_sim:object( box.id )
    if not boxobj then return result end
    local metka = find_metka_near_box( boxobj )
    if metka == nil then return result end
    local vname = get_npc_name( victim )
    local mtext = "На территории "
                    .. news_main.get_level_name( news_main.get_object_levelname( victim ) ) .. "."
    if result then
        amk.send_tip( mtext, "Зафиксирован взрыв схрона", 0, 10, "gen_info" )
        --amk.add_spot_on_map(victim.id, spot_type, "Мародер-неудачник "..vname)
    else
        if lua_random() < 0.2 then
            amk.send_tip( mtext, "Схрон раскрыт", 0, 10, "gen_info" )
        end
        --amk.add_spot_on_map(victim.id, spot_type, "Мародер "..vname)
    end
    --set_metka_victim(metka.id, victim.id)
    return result
end

function blow_habar_out( box_id )
    if #items[ box_id ] == 0 then return end
    local boxobj = g_sim:object( box_id )
    if not boxobj then return end
    local habar = {}
    local rnd   = 1000 / #items[ box_id ]
    for iter, zzz in pairs( items[ box_id ] ) do
        if rnd >= my_lua_random( 100 ) then
            local v_itA = items[ box_id ][ iter ]
            if v_itA then
                local itA = g_sim:object( v_itA.id )
                if
                    itA and itA:name() == v_itA.name and itA.parent_id == box_id
                    and not str_in_tab(
                        itA:section_name(), { "grenade_", "outfit", "wpn_", "closer_"}
                    )
                then 
                    table.insert( habar, itA )
                    if #habar == 5 then break end
                end
            end
        end
    end
    local base_dir = vector():set( boxobj.position.x, boxobj.position.y, boxobj.position.z )
    for iter = 1, #habar do
        local obj    = habar[ iter ]
        local ang    = my_lua_random() * 2.0 * math.pi
        local radius = my_lua_random() * 1.5
        local dir    = vector():set( math.cos( ang ), 0.0, math.sin( ang ) )
        local lv     = boxobj.m_level_vertex_id
        local pos    = vector():set(
                        base_dir.x + radius * dir.x, base_dir.y + 0.5, base_dir.z + radius*dir.z
                    )
        if
            lv and boxobj.m_game_vertex_id
            and game_graph():valid_vertex_id( boxobj.m_game_vertex_id )
        then
            local new = create_newitem( obj, pos, lv, boxobj.m_game_vertex_id, BAD_OBJ_ID )
        end
        if new then add_fresh_meat( new ) end
        do_drop_object( obj )
    end 
end

function my_lua_random( lower )
    local cnt = lua_random( 5 )
    local res
    if lower then
        for iter = 0, cnt do res = lua_random( lower ) end
    else
        for iter = 0, cnt do res = lua_random() end
    end
    return res
end

function check_box_trap_trigger( victim, box )
    local grenades = {}
    for iter, zzz in pairs( items[ box.id ] ) do
        local v_itA = items[ box.id ][ iter ]
        if v_itA then
            local itA = g_sim:object( v_itA.id )
            if
                itA and itA:name() == v_itA.name and itA.parent_id == box.id
                and ( itA:section_name() == "grenade_rgd5" or itA:section_name() == "grenade_f1" )
            then 
                table.insert( grenades, itA )
                if #grenades == 5 then break end
            end
        end
    end
    if #grenades <= 0 then return false end
    local rank  = victim:rank()
    local f1f   = 85
    local rgd5f = 93
    if rank < 300 then
        f1f   = 20
        rgd5f = 27
    elseif rank < 600 then
        f1f   = 35
        rgd5f = 42
    elseif rank < 900 then
        f1f   = 55
        rgd5f = 63
    elseif rank < 2000 then
        f1f   = 75
        rgd5f = 85
    end 
    local failed = false
    for iter = 1, #grenades do
        local grenade = grenades[ iter ]
        local grf
        local itA = g_sim:object( grenade.id )
        if itA and string.find( itA:name(), "_rgd5", 1, true ) then
            grf = rgd5f
        else
            grf = f1f
        end
        local rnd = my_lua_random( 100 )
        if grf >= rnd then
            pick_item( victim, itA )
        else
            do_drop_object( itA )
            failed = true
            break
        end
    end 
    if failed then
        set_npc_health( victim, health_wound_set )
        blow_habar_out( box.id )
    end 
    return failed
end

function do_drop_item( obj )
    if obj and db.actor and obj.id ~= db.actor:id() then
        if obj.parent_id and items[ obj.parent_id ] and #items[ obj.parent_id ] > 0 then
            for z, v in pairs( items[ obj.parent_id ] ) do
                if
                    items[ obj.parent_id ][ z ]
                    and items[ obj.parent_id ][ z ].id == obj.id
                then
                    items[ obj.parent_id ][ z ] = nil
                    gps_habar.remove_item( obj.parent_id, items[ obj.parent_id ][ z ] )
                    break
                end
            end
        end
    end
end

function do_drop_object( obj )
    if obj and db.actor and obj.id ~= db.actor:id() then
        clear_item_owner( obj.id )
        do_drop_item( obj )
        misc.release_obj( obj.id, 'amk_offline_alife.do_drop_object' )
    end
end

function get_ammo_size( obj )
    return vergas_lib.get_ammo_size( obj )
end

function create_newitem( obj, pos, lvi, gvi, pid )
    if obj and obj.id then 
    if g_sim:object( obj.id ) == nil then return nil end
        obj = g_sim:object( obj.id )
        if is_ammo( obj ) then
            local cnt = get_ammo_size( obj )
            if cnt > 0 then
                return g_sim:create_ammo(
                    obj:section_name(), pos, lvi, gvi, pid, cnt
                )
            end
        else
            local item_cond = 1
            local pk        = get_netpk( obj, 1 )
            local data      = pk:get()
            item_cond       = data.condition
            local new_itm   = g_sim:create( obj:section_name(), pos, lvi, gvi, pid )
            if new_itm then
                pk             = get_netpk( new_itm, 1 )
                data           = pk:get()
                data.condition = item_cond
                pk:set( data )
                return new_itm
            end
        end
    end
    return nil
end

function npc_has_same_wo( npc, obj )
    if npc and npc.id and items[ npc.id ] then
        if obj and obj.id then
            if g_sim:object( obj.id ) == nil then return false end
            local objname = g_sim:object( obj.id ):name() or ""
            if not objname or objname == "" then return end
            if strpos( objname, "^wpn_" ) or strpos( objname, "_outfit", 1, true ) then
                for i, v_itA in pairs( items[ npc.id ] ) do
                    if v_itA then
                        local itA = g_sim:object( v_itA.id )
                        if
                            itA and itA:name() == v_itA.name
                            and itA.parent_id == npc.id
                            and itA:name() == objname
                        then
                            return true
                        end
                    end
                end
            end
        end
    end
    return false
end

function pick_item( npc, obj )
    local new = nil
    if npc and obj and db.actor and obj.id ~= db.actor:id() then
        --npc does not take a weapon or an outfit if he already has the same
        if npc_has_same_wo( npc, obj ) then return new end
        new = create_newitem(
            obj, npc.position, npc.m_level_vertex_id, npc.m_game_vertex_id, npc.id
        )
        if new then
            if new.parent_id then
                if not items[ new.parent_id ] then items[ new.parent_id ] = {} end
                table.insert( items[ new.parent_id ], { id = new.id, name = new:name() } )
            end
            do_drop_object( obj )
        end
    end
    return new
end

function get_npc_weapon( npc )
    local obj = nil
    local fp  = 0
--get_console():execute("get_npc_weapon"..npc:name())
    if npc then
        for k, v in pairs( items[ npc.id ] ) do
            local wpn = g_sim:object( v.id )
            if
                wpn and isWeapon(wpn )
                and wpn:name()    == v.name
                and wpn.parent_id == npc.id
            then
                local cur_fp = get_weapon_firepower( wpn )
                if cur_fp > fp then
                    fp  = cur_fp
                    obj = wpn
                end         
            end
        end
    end
    return obj
end

function load_weapon_params( wpn )
    if not wpn then return end
    local wpnsect = wpn:section_name()
    if wpn_fp[ wpnsect ] then return end
    if isWeapon( wpn ) then
        if not strpos( wpnsect, "grenade", 1, true ) then
            local sl = utils.cfg_get_number( sini, wpnsect, "slot", wpn, false, 0 )
            if sl <= 0 then return end
            local priority  = utils.cfg_get_number( sini, wpnsect, "ef_weapon_type", wpn, false, 1 )
            local priority2 = utils.cfg_get_number( sini, wpnsect, "ef_main_weapon_type", wpn, false, 0 )
            if priority > 1 and priority2 > 0 then
                priority = priority + priority2
            end
            local fp = math.ceil( priority * 1000 ) - 5000
            local ac = utils.cfg_get_string( sini, wpnsect, "ammo_class", wpn, false, "" )
            wpn_fp[ wpnsect ] = { frp = fp, ammo = ac, slot = sl, p = priority }
        end
    end
end

function get_weapon_slot( wpn )
    if wpn then
        local wpnsect = wpn:section_name() or wpn:section()
        if not wpn_fp[ wpnsect ] then load_weapon_params( wpn ) end
        if wpn_fp[ wpnsect ] then return wpn_fp[ wpnsect ].slot end
    end
    return 0
end

function get_weapon_ammo( wpn )
    if wpn then
        local wpnsect = wpn:section_name() or wpn:section()
        if not wpn_fp[ wpnsect ] then load_weapon_params( wpn ) end
        if wpn_fp[ wpnsect ] then return wpn_fp[ wpnsect ].ammo end
    end
    return ""
end

function get_weapon_firepower( wpn )
    if wpn then
        local wpnsect = wpn:section_name() or wpn:section()
        if not wpn_fp[ wpnsect ] then load_weapon_params( wpn ) end
        if wpn_fp[ wpnsect ] then return wpn_fp[ wpnsect ].frp end
    end
    return 0
end

function get_weapon_cost( weapon )
    local result = 0
    if weapon and isWeapon( weapon ) then
        result = get_item_cost( weapon )
    end
    return result
end

function get_item_cost( item )
    local result = 0
    if item and item.section_name then
        local sect = item:section_name() or item:section()
        if item_cost[ sect ] then
            result = item_cost[ sect ]
        else
            result = utils.cfg_get_number( sini, sect, "cost", item, false, 0 )
            item_cost[ sect ] = result
        end
    end
    return result
end

function set_npc_health( obj, health )
    if ( obj and health >= 0 and health <= 2 ) then
        local pk        = get_netpk( obj )
        local data      = pk:get()
        data.health     = health
        data.upd.health = health
        pk:set( data )                                                                                    
        if health == 0 then on_death( obj.id ) end
    end
end

function list_npc_items( obj )
    if obj then
        --amk.mylog("list_npc_items - "..obj:name()..":")
        local it
        local find = 0
        --ODS("[~T]. #DBG: 64K enum 9")
        for a = 1, MAX_OBJ_ID do
            it = g_sim:object( a )
            if it and it.parent_id == obj.id then
                --amk.mylog("list_npc_items - "..it:name().." "..it:section_name())
                if ( _g.isWeapon( it ) ) then find = it.id end
            end         
        end
    end
end

function dbg_show_team( team )
    if team then
        for k, player in pairs( team ) do
            if player.weapon then
                mylog(
                    "Team: " .. player.player:name() .. " health=" .. player.health
                    .. " rank=" .. player.rank .. " community=" .. player.player:community()
                    .. " weapon=" .. player.weapon:name() .. " firepower=" .. player.firepower
                )
            else
                mylog(
                    "Team: " .. player.player:name() .. " health=" .. player.health
                    .. " rank=" .. player.rank .. " community=" .. player.player:community()
                    .. " weapon=none firepower=" .. player.firepower
                )
            end
        end
    end
end

--[[
    Уникальные предметы НЕ ПРОДАЕМ. Максимум - в новости.   
    Отсортировали оружие по firepower(можем еще ef_weapon_type добавить.)
    Оставили себе то, для которого есть патроны.(а) - wpn..ammo_class + item_dependence
    Оставили одно, которое лучше(а), но патронов нет(б)(%)
    Одно, которое лучше(а), но хуже(б) - в новости на продажу
    Остальное на продажу
    Патроны оставили только те, что подходят к(а), остальные на продажу
    Для вояк - только родной калаш надо бы... Не продавать вобще?
    Оставляем не более 2 аптечек и бинтов, антирада
    Оставляем 1-2 гранаты(%)
    Оставляем не более 1 шт: фонарик, рация, ПДА, бинокль, нож, детекторы
    Еда, водка - не более 1-2 шт(%) 
    Броники наверное продаем...
    Части монстров? Тоже продаем наверное, максимум 1-2 оставим.
]]
function process_trade( npc, vdata )  
    local item_list, sell_list = {}, {}
    if
        npc and IsStalker( npc ) and npc:alive()
        and ( npc.m_story_id == nil or npc.m_story_id == NONE_SID or npc.m_story_id == NONE_CL_SID )
        and items[ npc.id ] and #items[npc.id] > 0
    then
        local m_comm    = npc:community()
        local b_stalker = false     
        if
               m_comm == "actor"
            or m_comm == "actor_dolg"
            or m_comm == "actor_freedom"
            or m_comm == "stalker"
            or m_comm == "dolg"
            or m_comm == "freedom"
            or m_comm == "green"
        then
            b_stalker = true
        elseif
               m_comm == "zombied"
            or m_comm == "military"
        then
            return
        end
        local obj, v_obj
        for ok, ov in pairs( items[ npc.id ] ) do
            obj = g_sim:object( ov.id )
            if obj and obj:name() == ov.name then
                if
                    always_keep_item[ obj:section_name() ]
                    or sell_table[ obj:section_name() ] == nil
                then
                    --ODS("[~T]. #DBG: Process_trade: "..npc:name().." ["..m_comm.."] filtered "..obj:section_name().." ["..obj:name().."]")
                else
                    table.insert( item_list, obj )
                    --item_list[v.id] = obj
                    --ODS("[~T]. #DBG: Process_trade: "..npc:name().." ["..m_comm.."] have "..obj:section_name().." ["..obj:name().."]")
                end
            end
        end
        if item_list and #item_list > 0 then
            --ODS("[~T]. #DBG: Process_trade: "..npc:name().." ["..m_comm.."] have "..tostring(table.getn(item_list)).." items.")
            table.sort( item_list, function( a, b ) return get_item_cost( a ) > get_item_cost( b ) end )     
            local cnt_medkit    = 0
            local cnt_antirad   = 0
            local cnt_bandage   = 0
            local cnt_grenade   = 0
            local cnt_food      = 0
            local cnt_drink     = 0
            local cnt_torch     = 0
            local cnt_pda       = 0
            local cnt_radio     = 0
            local cnt_guitar    = 0
            local cnt_harmonica = 0
            local cnt_binocular = 0
            local cnt_knife     = 0
            local cnt_arts      = 0
            local cnt_detector  = 0
            local cnt_addons    = 0
            local cnt_mparts    = 0
            local cnt_outfits   = 0
            local cnt_b_best    = 0
            local weapons1      = {}
            local weapons2      = {}
            local ammo          = {}
            for k, v in pairs( item_list ) do          
                local sect  = v:section_name() or v:section()
                local cl_id = v:clsid()
                --ODS("[~T]. #DBG: Process_trade: first pass - "..npc:name().." ["..m_comm.."] have "..sect.." ["..v:name().."]")
                if isWeapon_no_gren( v ) then
                    local ac = get_weapon_ammo( v )
                    if ac and ac ~= "" then
                        local vvv = amk.str_explode( ",", ac, true )
                        local ammo_classes = {}
                        for ak, av in pairs( vvv ) do
                            table.insert( ammo_classes, av )
                        end
                        local slot = get_weapon_slot( v )
                        if slot == 1 then
                            table.insert( weapons1, { obj = v, ammo = ammo_classes } )
                        elseif slot == 2 then
                            table.insert( weapons2, { obj = v, ammo = ammo_classes } )
                        end
                    else
                        table.insert( weapons1, { obj = v, ammo = nil } )
                    end
                elseif isAmmo( v ) then
                    if ammo[ sect ] == nil then 
                        ammo[ sect ] = 1
                    else
                        ammo[ sect ] = ammo[ sect ] + 1
                        if ammo[ sect ] > 3 then table.insert( sell_list, v ) end
                    end
                elseif isArt( v ) then
                    cnt_arts = cnt_arts + 1
                    if cnt_arts > 2 then table.insert( sell_list, v ) end             
                elseif isOutfit( v ) then     
                    cnt_outfits = cnt_outfits + 1
                    if cnt_outfits > 1 then table.insert( sell_list, v ) end 
                elseif isGrenade( v ) then
                    cnt_grenade = cnt_grenade + 1
                    if cnt_grenade > 2 then table.insert( sell_list, v ) end                 
                elseif cl_id == CLID_TORCH then
                    cnt_torch = cnt_torch + 1
                    if cnt_torch > 1 then table.insert( sell_list, v ) end
                elseif cl_id == CLID_MEDKIT then
                    cnt_medkit = cnt_medkit + 1
                    if cnt_medkit > 2 then table.insert( sell_list, v ) end
                elseif cl_id == CLID_ANTIRAD then
                    cnt_antirad = cnt_antirad + 1
                    if cnt_antirad > 1 then table.insert( sell_list, v ) end
                elseif cl_id == CLID_BANDAGE then
                    cnt_bandage = cnt_bandage + 1
                    if cnt_bandage > 3 then table.insert( sell_list, v ) end
                elseif cl_id == CLID_BREAD then
                    cnt_food = cnt_food + 1
                    if cnt_food > 4 then table.insert( sell_list, v ) end
                elseif cl_id == CLID_DRINK then
                    cnt_drink = cnt_drink + 1
                    if cnt_drink > 3 then table.insert( sell_list, v ) end
                elseif cl_id == CLID_DETECTOR then
                    cnt_detector = cnt_detector + 1
                    if cnt_detector > 2 then table.insert( sell_list, v ) end
                elseif strpos( sect, "wpn_addon_", 1, true ) then
                    cnt_addons = cnt_addons + 1
                    if cnt_addons > 2 then table.insert( sell_list, v ) end
                elseif strpos( sect, "mutant_", 1, true ) then
                    cnt_mparts = cnt_mparts + 1
                    if cnt_mparts > 2 then table.insert( sell_list, v ) end
                else
                    table.insert( sell_list, v )
                end         
            end
            table.sort(
                weapons1,
                function( a, b )
                    return get_weapon_firepower( a.obj ) > get_weapon_firepower( b.obj )
                end
            )
            table.sort(
                weapons2,
                function( a, b )
                    return get_weapon_firepower( a.obj ) > get_weapon_firepower( b.obj )
                end
            )
            local b_self = false
            local b_best = false
            local s_self = ""
            for k, v in pairs( weapons1 ) do
                local b_ammo = false
                local vac    = v.ammo
                if vac and #vac > 0 then
                    for kk, vv in pairs( vac ) do
                        if ammo[ vv ] and ammo[ vv ] > 0 then
                            b_ammo = true
                            break
                        end
                    end
                end
                if b_self == false and b_ammo == true then
                    b_self = true
                    s_self = v.obj:section_name() or v.obj:section()
                elseif b_best == false then
                    if s_self ~= "" then
                        if v.obj:section_name() ~= s_self then
                            b_best     = true
                            cnt_b_best = cnt_b_best + 1
                            if cnt_b_best > 1 then
                                table.insert( sell_list, v.obj )
                            end
                        else
                            table.insert( sell_list, v.obj )
                        end
                    else
                        b_best = true
                    end
                else
                    table.insert( sell_list, v.obj )
                end
            end
            b_self = false
            b_best = false
            s_self = ""
            for k, v in pairs( weapons2 ) do
                local b_ammo = false
                local vac    = v.ammo
                if vac and #vac > 0 then
                    for kk, vv in pairs( vac ) do
                        if ammo[ vv ] and ammo[ vv ] > 0 then -- Так, патроны есть.
                            b_ammo = true
                            break
                        end
                    end
                end
                if b_self == false and b_ammo == true then
                    b_self = true
                    s_self = v.obj:section_name() or v.obj:section()
                elseif b_best == false then
                    if s_self ~= "" then
                        if v.obj:section_name() ~= s_self then
                            b_best     = true
                            cnt_b_best = cnt_b_best + 1
                            if cnt_b_best > 1 then
                                --ODS("[~T]. #DBG: Process_trade: second pass - "..npc:name().."_["..m_comm.."]_BEST weapon is_"..v.obj:section_name().."_["..v.obj:name().."]"..cnt_b_best)
                                table.insert( sell_list, v.obj )
                            end
                        else
                            table.insert( sell_list, v.obj )
                        end
                    else
                        b_best = true
                    end
                else
                    table.insert( sell_list, v.obj )
                end
            end
            item_list = nil
            if sell_list and #sell_list > 0 then
                table.sort(
                    sell_list,
                    function( a, b )
                        return get_item_cost( a ) > get_item_cost( b )
                    end
                )     
                local zz = sell_list[ 1 ]
                if
                    zz and b_stalker == true
                    and get_item_cost( zz ) >= sell_limit
                then
                    --ODS("[~T]. #DBG: Offline: "..npc:name().." собирается продать через новости "..zz:name())
                    news_main.on_offline_trade( npc, zz )
                    table.remove( sell_list, 1 )
                end
            end
            local money = 0
            for kk, vv in pairs( sell_list ) do
                --ODS("[~T]. #DBG: Process_trade: final pass - "..npc:name().." ["..m_comm.."] sells "..vv:section_name().." ["..vv:name().."]")
                local cost = get_item_cost( vv )
                if cost > 0 then
                    s_name = utils.cfg_get_string( sini, vv:section_name(), "inv_name", vv, false, "", "" )
                    if s_name == nil then s_name = "" end
                    s_name = game.translate_string( s_name )
                    money  = money + cost
                    if items[ npc.id ] and #items[ npc.id ] > 0 then
                        for zzz, vvv in pairs( items[ npc.id ] ) do
                            if items[ npc.id ][ zzz ] and items[ npc.id ][ zzz ].id == vv.id then
                                gps_habar.remove_item( npc.id, items[ npc.id ][ zzz ] )
                                items[ npc.id ][ zzz ] = nil
                                break
                            end
                        end
                    end
                    misc.release_obj( vv.id, 'amk_offline_alife.Process_trade' )
                end             
            end
            if money > 0 then
                local pk   = get_netpk( npc )
                local data = pk:get()
                data.money = data.money + money
                pk:set( data )                                                                            
            end
        end
    end
end

function get_monster_params( obj )
    if
        obj
        and ( IsMonster( obj ) or ( obj.community and obj:community() == "zombied" ) )
    then
        if
            monster_params
            and monster_params[ obj:section_name() ]
        then
            return monster_params[ obj:section_name() ]
        else
            local speed = utils.cfg_get_number(
                sini, obj:section_name(), "MaxSpeed", obj, false, 5
            )
            local dist = utils.cfg_get_number(
                sini, obj:section_name(), "MaxAttackDist", obj, false, 3
            )
            local imm_sect = utils.cfg_get_string(
                sini, obj:section_name(), "immunities_sect", obj, false, "", ""
            )
            local immunity = utils.cfg_get_number(
                sini, imm_sect, "fire_wound_immunity", obj, false, 1
            )
            local att_sect = utils.cfg_get_string(
                sini, obj:section_name(), "attack_params", obj, false, "", ""
            ) 
            local attack = 0
            if sini:section_exist( att_sect ) then
                local result, id, value = nil, nil, nil
                local max_attack = 0
                for a = 0, sini:line_count( att_sect ) - 1 do
                    result, id, value = sini:r_line( att_sect, a, "", "" )
                    if
                        id ~= nil and trim( id ) ~= ""
                        and trim( id ) ~= nil and value ~= nil
                    then
                        local m_value = amk.str_explode( ",", amk.trim( value ), true )
                        if m_value and #m_value > 2 then
                            local v = tonumber( m_value[ 2 ] )
                            if v and v > max_attack then max_attack = v end
                        end
                    end
                end
                attack = max_attack
            end
            monster_params[ obj:section_name() ] = {
                speed    = speed,
                dist     = dist,
                immunity = immunity,
                attack   = attack
            }
            return monster_params[ obj:section_name() ]           
        end
    else
        return nil
    end
end

function sobj_is_far( obj, distance )
    local result = true
    if
        db.actor and obj and distance
        and obj.position and db.actor.position
    then
        if
            obj.m_game_vertex_id
            and game_graph():valid_vertex_id( obj.m_game_vertex_id )
        then
            local map = g_sim:level_name(
                game_graph():vertex( obj.m_game_vertex_id ):level_id()
            )
            if map and level.name() == map then
                if obj.position:distance_to( db.actor:position() ) < distance then
                    result = false
                end
            end
        end
    end
    return result
end

function game_minutes()
    local gtime = misc.game_time_minutes() 
    return gtime
end

function have_ammo( npc, weapon )
    local result = false
    if npc and weapon and IsStalker( npc ) and isWeapon( weapon ) then
        local ammo_str = get_weapon_ammo( weapon )
        if ammo_str == "" then return false end
        local ammo_list = parse_names( ammo_str )
        for k, v in items[ npc.id ] do
            if strpos( obj:section_name(), "ammo_", 1, true ) then end
        end
    end
    return result
end

function box_is_protected( v )
    if v then
        for k, o in pairs( protected ) do
            if type( o ) == "number" and v.m_story_id then
                if o == v.m_story_id then return true end
            elseif type( o ) == "string" then
                if o == v:name() then return true end
            end
        end
        if
               level.map_has_object_spot( v.id, "crlc_big_treasure1" ) ~= 0
            or level.map_has_object_spot( v.id, "crlc_big_treasure2" ) ~= 0
            or level.map_has_object_spot( v.id, "crlc_big_treasure3" ) ~= 0
            or level.map_has_object_spot( v.id, "crlc_big_treasure4" ) ~= 0
        then
            return true
        end
    end
    return false
end

function npc_smart_is_peaceful( sobj )
    local result = false
    if sobj and smart_filters and #smart_filters > 0 then
        if
            sobj.smart_terrain_id
            and sobj:smart_terrain_id()
            and sobj:smart_terrain_id() ~= BAD_OBJ_ID
        then
            local sm = g_sim:object( sobj:smart_terrain_id() )
            if sm and sm.name and sm:name() then
                local sn = sm:name()
                for ks, vs in pairs( smart_filters ) do
                    if vs == sn then
                        result = true
                        break
                    end
                end
            end
        end
    end
    return result
end

function on_death( npc_id )
    smart_terrain.on_death( npc_id )
end

function get_flags( npc_id )
    local flags = 0
    local obj   = g_sim:object( npc_id )
    if obj then
        if IsMonster( obj ) or IsStalker( obj ) then
            local char_ini = xr_logic.get_customdata_or_ini_file( obj, "<customdata>" )
            if char_ini:section_exist( "logic" ) then
                local from  = ""
                local items = ""
                if char_ini:line_exist( "logic", "on_hit" ) then
                    flags = 1
                end
                if char_ini:line_exist( "logic", "on_death" ) then
                    flags = flags + 2
                end
            end
        end
    end
    return flags
end

function is_valuable_for_player( item )
    local valitems = {
        "vodka",
        "bandage",
        "medkit",
        "antirad",
        "grenade",
        "mutant",
        "_pda"
    }
    if is_ammo( item ) then return true end
    if item and item.section_name then
        for iter = 1, #valitems do
            if strpos( item:section_name(), valitems[ iter ], 1, true ) then
                return true
            end
        end
    end
    return false
end

function is_valuable( item )
    local result = false
    if item and not ( IsMonster( item ) or IsStalker( item ) ) then
        if always_keep_item[ item:section_name() ] then
            return false
        else
            result = true
        end
    end
    return result
end

local status_boxs       = {}
local status_metka      = {}
local be_enemies        = {}
local item_owners       = {}
local trapped_bodies    = {}
local val_item_cost     = 4000
local val_min_item_cost = 1000
local be_enemy_time     = 60000
enemy_level_hit         = 1
enemy_level_kill        = 2
enemy_level_angry       = 3

function set_body_trap( npc_id, body_id )
    local npc  = g_sim:object( npc_id )
    local body = g_sim:object( body_id )
    if npc and body and IsStalker( body ) and body.rank then
        local rank = body:rank()
        local tp = 85
        if     rank < 300  then tp = 1 --novichek
        elseif rank < 600  then tp = 3 --stalker
        elseif rank < 900  then tp = 5 --veteran
        elseif rank < 2000 then tp = 7 --master
        end 
        if my_lua_random( 100 ) > tp then return end
        rank = npc:rank()
        if get_body_trap( body_id ) > rank then return end
        trapped_bodies[ body_id ] = rank
    end
end

function clear_body_trap( body_id )
    trapped_bodies[ body_id ] = nil
end

function get_body_trap( body_id )
    if trapped_bodies[ body_id ] then
        return trapped_bodies[ body_id ]
    else
        return 0
    end
end

function check_item_owners()
    for owner_id, items in pairs( item_owners ) do
        local obj = g_sim:object( owner_id )
        if not
            ( obj and IsStalker( obj ) and obj.health and obj:health() > 0 )
        then
            item_owners[ owner_id ] = nil
        end
    end
end

function set_item_owner( owner_id, item_id )
    clear_item_owner( item_id )
    if owner_id and item_id then
        if item_owners[ owner_id ] then
            --check item_id already exists
            for iter = 1, #item_owners[ owner_id ] do
                if item_owners[ owner_id ][ iter ] == item_id then return end
            end
        else
            item_owners[ owner_id ] = {}
        end
        table.insert( item_owners[ owner_id ], item_id )
    end
end

function clear_item_owner( item_id )
    if item_id then
        for owner_id, items in pairs( item_owners ) do
            for iter, zzz in pairs( items ) do
                if items[ iter ] == item_id then 
                    items[ iter ] = nil
                    if #items == 0 then
                        item_owners[ owner_id ] = nil
                    end
                    return owner_id
                end
            end
        end
    end
    return 0
end

function set_box_trapped( box_id, trap_rank )
    if not status_boxs[ box_id ] then
        if not trap_rank or trap_rank == 0 then return end
        status_boxs[ box_id ] = { trap_rank = 0, owner_id = BAD_OBJ_ID }
    end
    if trap_rank then
        status_boxs[ box_id ].trap_rank = trap_rank
    end
    check_box_remove( box_id )
end

function check_box_remove( box_id )
    if
        status_boxs[ box_id ]
        and status_boxs[ box_id ].trap_rank == 0
        and status_boxs[ box_id ].owner_id == BAD_OBJ_ID
    then
        status_boxs[ box_id ] = nil
    end
end

function set_box_owner( box_id, owner_id )
    if not status_boxs[ box_id ] then
        if not owner_id or owner_id == BAD_OBJ_ID then return end
        status_boxs[ box_id ] = { trap_rank = 0, owner_id = BAD_OBJ_ID }
    end
    if owner_id then
        status_boxs[ box_id ].owner_id = owner_id
    end
    check_box_remove( box_id )
end

function get_box_trap_rank( box_id )
    if status_boxs[ box_id ] then
        return status_boxs[ box_id ].trap_rank
    else
        return 0
    end
end

function get_box_owner( box_id )
    if status_boxs[ box_id ] then
        return status_boxs[ box_id ].owner_id
    else
        return BAD_OBJ_ID
    end
end

function actor_check_body( npc )
    if npc then
        body_blow_id = npc:id()
        local armor  = db.actor:item_in_slot( 6 )
        if
            armor
            and strposx( armor:section(), "monolit" )
        then
            return
        end
        amk_mod.try_add_black_tip( level.name(), npc:id() )
    end
end

function give_treasure( npc )
    if not npc then return false end
    local npc_id  = npc:id()
    local res     = false
    local boxlist = {}
    for iter, box in pairs( status_boxs ) do
        if box.owner_id == npc_id then
            local box = g_sim:object( iter )
            if box.m_story_id then
                table.insert( boxlist, box.m_story_id )
            end
            res = true
            set_box_owner( iter, BAD_OBJ_ID )
        end
    end
    return res, boxlist
end

function item_change( obj )
    local sobj = g_sim:object( obj:id() )
    if sobj then
       do_drop_item( sobj )
       add_fresh_meat( sobj )
    end
end

function set_metka_victim( metka_id, victim_id )
    if not victim_id or victim_id == BAD_OBJ_ID then return end
    if not status_metka[ metka_id ] then
        status_metka[ metka_id ] = {}
    end
    table.insert( status_metka[ metka_id ], victim_id )
end

function check_metka_take( obj )
        local sobj = g_sim:object( obj:id() )
        if sobj and sobj:section_name() == "amk_metka" then
        if status_metka[ sobj.id ] then
            for iter = 1, #status_metka[ sobj.id ] do
                amk.remove_spot_from_map(
                    status_metka[ sobj.id ][ iter ], "red_location"
                )
            end
            status_metka[ sobj.id ] = nil
        end
    end
end

function on_item_take( obj )
    if not obj then return end
    item_change( obj )
    check_metka_take( obj )
end

function on_item_drop( obj )
    if not obj then return end
    item_change( obj )
    local sobj = g_sim:object( obj:id() )
    if sobj and sobj.parent_id then
        set_box_owner( sobj.parent_id, BAD_OBJ_ID )
    end
end

function take_item_from_box(box, item)
    local box_id    = box:id()
    local trman     = treasure_manager.get_treasure_manager()
    local needempty = true
    if trman then
        local bstid = box:story_id()
        if bstid then
            local k = trman.treasure_by_target[ bstid ]
            if k and trman.treasure_info[ k ] then 
                needempty = false
            end
        end
    end
    if
        needempty
        and (
               level.map_has_object_spot( box_id, "crlc_big_treasure1" ) ~= 0
            or level.map_has_object_spot( box_id, "crlc_big_treasure2" ) ~= 0
            or level.map_has_object_spot( box_id, "crlc_big_treasure3" ) ~= 0
            or level.map_has_object_spot( box_id, "crlc_big_treasure4" ) ~= 0
        )
    then
        for spot = 1, 4 do
            level.map_remove_object_spot( box_id, "crlc_big_treasure" .. spot )
        end
        empty_treasure( box_id )
    end
    if item then
        local itemid = item:id()
        if items[ box_id ] and #items[ box_id ] > 0 then
            for z, v in pairs( items[ box_id ] ) do
                if items[ box_id ][ z ] and items[ box_id ][ z ].id == itemid then
                    items[ box_id ][ z ] = nil
                    break
                end
            end
        end
        local owner_id = clear_item_owner( itemid )
        local p_obj    = g_sim:object( box_id )
        if box_is_protected( p_obj ) == true then return end
        if owner_id and owner_id > 0 and owner_id ~= BAD_OBJ_ID then
            set_box_owner( box_id, BAD_OBJ_ID )
            local owner = g_sim:object( owner_id )
            if not
                ( owner and IsStalker( owner ) and owner.health and owner:health() > 0 )
            then
                sak.send_tip(
                    "Владелец этой вещи умер...", "Чужая вещь", 0, 10, "default", "task", "green"
                )
                return
            end
            local itemcost    = get_item_cost( g_sim:object( itemid ) )
            local enemy_level = 0
            local goodwill_d  = 0
            if itemcost >= val_item_cost then
                enemy_level = enemy_level_kill
                goodwill_d  = -125
            elseif itemcost >= val_min_item_cost then
                goodwill_d  = -100
                enemy_level = enemy_level_hit
            else
                goodwill_d  = -50
            end
            local npc = client_obj( owner_id )
            local rel = game_object.neutral
            if npc then
                rel = npc:relation( db.actor )
                npc:change_goodwill( goodwill_d, db.actor )
                local newrel = npc:relation( db.actor )
                if enemy_level < enemy_level_kill and rel < newrel then
                    if newrel == game_object.enemy then
                        for iter = 1, 6 do
                            npc:change_goodwill( 25, db.actor )
                            if newrel > npc:relation( db.actor ) then break end
                        end
                    end
                    if enemy_level == enemy_level_hit then
                        enemy_level = enemy_level_kill
                    else
                        enemy_level = enemy_level_hit
                    end
                end
                rel = npc:relation( db.actor )
            end
            local was_enemy = be_enemies[ owner_id ]
            if was_enemy == enemy_level_hit or was_enemy == enemy_level_kill then
                if enemy_level < was_enemy then
                    enemy_level = was_enemy
                end
                if enemy_level == enemy_level_hit then
                    enemy_level = enemy_level_kill
                end
            end
            local vname = amk_offline_alife.get_npc_name( owner )
            local grupp = game.translate_string( owner:community() )
            if rel == game_object.enemy then
                local mtext = vname .. ". " .. grupp .. ".\\nПоймает - руки повыдергивает!"
                sak.send_tip(
                    "Эту вещь положил " .. mtext, "Чужая вещь", 0, 10, "default", "task", "red"
                )
                clear_be_enemy( owner_id )
            else
                if enemy_level == enemy_level_kill then
                    local mtext = vname .. ". " .. grupp .. ".\\nУвидит - убъёт!"
                    sak.send_tip(
                        "Эту вещь положил " .. mtext, "Чужая вещь", 0, 10, "default", "task", "red"
                    )
                    set_be_enemy( owner_id, enemy_level )
                elseif enemy_level == enemy_level_hit then
                    local mtext = vname .. ". " .. grupp .. ".\\nБыть чьей-то роже битой..."
                    sak.send_tip(
                        "Эту вещь положил " .. mtext, "Чужая вещь", 0, 10, "default", "task", "pink"
                    )
                    set_be_enemy( owner_id, enemy_level )
                else
                    local mtext = vname .. ". " .. grupp .. ".\\nЛучше положить на место, а то обидится..."
                    sak.send_tip(
                        "Эту вещь сховал " .. mtext, "Чужая вещь", 0, 10, "default", "task", "yellow"
                    )
                end
            end
        end
    end
end

local trap_timer = nil
local need_hit   = false
local trap_rank

function actor_update( delta )
    --check if actor is close to trapped box
    if body_blow_id then
        check_body_trap( body_blow_id )
        body_blow_id = nil
    end
    if need_hit and not sleep_manager.is_sleep_active() then
        need_hit = false
        trap_hit_actor()
        return
    end
    if trap_timer then
        if time_global() >= trap_timer then
            trap_timer = nil
            need_hit   = true
            sleep_manager.main( 2 )
        end
        return
    end
    --check_be_enemy()
    local mi = level.main_input_receiver()
    if mi then
        for iter, box in pairs( status_boxs ) do
            if box.trap_rank > 0 then
                local inv_box = g_sim:object( iter )
                if
                    inv_box and inv_box:section_name() == "inventory_box"
                    and not sobj_is_far( inv_box, 2.0 )
                then
                    trap_rank = box.trap_rank
                    set_box_trapped( iter, 0 )
                    trap_explosion( inv_box )
                    if not db.actor:item_in_slot( 6 ) then
                        trap_hit_actor( true )
                        return
                    end
                    level.add_cam_effector(
                        "camera_effects\\dis_consciousness.anm", 25, false, ""
                    )
                    trap_timer = time_global() + 4500
                    break
                end
            end
        end
    end
end

function check_body_trap( body_id )
    trap_rank = get_body_trap( body_id )
    if trap_rank <=0 then return end
    local body = g_sim:object( body_id )
    if not
        ( body and IsStalker( body ) and body.alive and not body:alive() )
    then
        return
    end
    trap_explosion( body )
    if not db.actor:item_in_slot( 6 ) then
        trap_hit_actor( true )
    else
        trap_hit_actor()
    end
    clear_body_trap( body_id )
end

function trap_hit_stalkers( pos )
    local level_name = level.name()
    if off_npcs[ level_name ] then 
        for iter, stalker in pairs( off_npcs[ level_name ].stalkers ) do
            local obj = g_sim:object( stalker.id )
            if
                obj and obj:name() == stalker.name
                and obj.online and obj.alive and obj:alive()
                and obj.health and obj:health() > health_wound_set
            then
                if obj.position:distance_to( pos ) <= 7 then
                    set_npc_health( obj, health_wound_set )
                end
            end
        end
    end
end

function trap_hit_armor()
    if not trap_rank then return end
    local armor_damage = 0.25
    if     trap_rank < 300  then armor_damage = 0.05
    elseif trap_rank < 600  then armor_damage = 0.1
    elseif trap_rank < 900  then armor_damage = 0.15
    elseif trap_rank < 2000 then armor_damage = 0.2
    end 
    local armor = db.actor:item_in_slot( 6 )
    if armor then
        local protection = utils.cfg_get_number(
            sini, armor:section(), "explosion_protection", nil, false, 0.4
        )
        if protection <= 0 then protection = 0.05 end
        local factor = math.pow( protection, 0.33 ) * ( 1 - armor_damage )
        armor:set_condition( armor:condition() * factor )
    end
end

function trap_hit_actor( strong )
    if not trap_rank or trap_rank <= 0 then return end
    local h = hit()
    local hit_power
    if strong then
        hit_power = 100
    else
        hit_power = 1.0
        if     trap_rank < 300  then hit_power = 0.2
        elseif trap_rank < 600  then hit_power = 0.4
        elseif trap_rank < 900  then hit_power = 0.6
        elseif trap_rank < 2000 then hit_power = 0.8
        end 
    end
    h.power     = hit_power
    h.impulse   = 1
    h.draftsman = db.actor
    h.direction = vector():set( 0, 0, 0 )
    h:bone( "bip01_spine" )
    h.type = hit.fire_wound
    db.actor:hit( h )
    level.add_pp_effector( "amk_shoot.ppe", 2011, false )
end

function trap_explosion( box )
    local mi = level.main_input_receiver()
    if mi then
        mi:GetHolder():start_stop_menu( mi, true )
    end
    local h     = hit()
    h.power     = 0.01
    h.impulse   = 500
    h.draftsman = db.actor
    local bpos  = box.position
    amk_particle.amk_particle({
        particle = [[explosions\explosion_dynamite]],
        pos      = bpos,
        sound    = [[weapons\rpg7_explode]]
    })
    local apos = db.actor:position()
    local dist = box.position:distance_to( apos )
    if dist > 0 then
        h.direction = vector():set(
            ( apos.x - bpos.x ) / dist,
            ( apos.y - bpos.y ) / dist,
            ( apos.z - bpos.z ) / dist
        )
        h.type = hit.explosion
        db.actor:hit( h )
    end
    trap_hit_armor()
    trap_hit_stalkers( bpos )
    local active_item = db.actor:active_item()
    if
        active_item and active_item:section() ~= "bolt"
        and active_item:section() ~= "wpn_knife"
    then
        db.actor:drop_item( active_item )
    end
end

function save_nested_data( p, data )
    if data then
        local size = 0
        for iter, d in pairs( data ) do size = size + 1 end
        p:w_u16( size )
        for iter, d in pairs( data ) do
            p:w_u16( iter )
            local msize = #d
            p:w_u16( msize )
            for iter = 1, msize do p:w_u16( d[ iter ] ) end
        end
    end
end

function save( p )
    local ver  = 4
    p:w_u16( ver )
    local size = 0
    for boxid, box in pairs( status_boxs ) do
        size = size + 1
    end
    p:w_u16( size )
    for boxid, box in pairs( status_boxs ) do
        p:w_u16( boxid )
        p:w_u32( box.trap_rank )
        p:w_u16( box.owner_id )
    end
    save_nested_data( p, status_metka )
    save_nested_data( p, item_owners  )
    size = 0
    for npc_id, lvl in pairs( be_enemies ) do
        size = size + 1
    end
    p:w_u16( size )
    for npc_id, lvl in pairs( be_enemies ) do
        p:w_u16( npc_id )
        p:w_u8( lvl )
    end
    size = 0
    for body_id, tr in pairs( trapped_bodies ) do
        size = size + 1
    end
    p:w_u16( size )
    for body_id, tr in pairs( trapped_bodies ) do
        p:w_u16( body_id )
        p:w_u32( tr )
    end
end

local loaded = false

function load_nested_data( p, data )
    if data then
        local size = p:r_u16()
        for iter = 1, size do
            local id    = p:r_u16()
            data[ id ]  = {}
            local msize = p:r_u16()
            for jter = 1, msize do
                table.insert( data[ id ], p:r_u16() )
            end
        end
    end
end

function load( p )
    local ver   = p:r_u16()
    status_boxs = {}
    local size  = p:r_u16()
    for iter = 1, size do
        local boxid = p:r_u16()
        status_boxs[ boxid ] = { trap_rank = 0, owner_id = BAD_OBJ_ID }
        status_boxs[ boxid ].trap_rank = p:r_u32()
        status_boxs[ boxid ].owner_id  = p:r_u16()
    end
    status_metka   = {}
    load_nested_data( p, status_metka )
    be_enemies     = {}
    item_owners    = {}
    trapped_bodies = {}
    if ver > 1 then
        load_nested_data( p, item_owners )
        size = p:r_u16()
        for iter = 1, size do
            if ver > 2 then
                local npc_id = p:r_u16()
                be_enemies[ npc_id ] = p:r_u8()
            else
                be_enemies[ p:r_u16() ] = enemy_level_kill
            end
        end
        if ver > 3 then
            local size = p:r_u16()
            for iter = 1, size do
                local bodyid = p:r_u16()
                trapped_bodies[ bodyid ] = p:r_u32()
            end
        end
    end
    loaded = true
end

function get_item_box_cost( box_id )
    local res = 0
    if not items[ box_id ] then return res end
    local whomid = db.actor:id()
    for iter = 1, #items[ box_id ] do
        local v_itA = items[ box_id ][ iter ]
        if v_itA then
            local itA = g_sim:object( v_itA.id )
            if
                itA and itA:name() == v_itA.name
                and ( itA.parent_id == box_id or itA.parent_id == whomid )
            then
                res = res + get_item_cost( itA )
            end
        end
    end
    return res
end

local spawn_maps = {

    [ "l01_escape" ] = {
        creatures = {
            "esc_bandit_respawn_1",
            "esc_bandit_respawn_2",
            "esc_soldier_respawn_1"
        },
        sounds = {
            [[bandit\fight\attack\attack_1]],
            [[bandit\fight\attack\attack_2]],
            [[military\fight\attack\attack_1]]
        }
    },

    [ "l02_garbage" ] = {
        creatures = {
            "gar_bandit_respawn_1",
            "gar_bandit_respawn_2"
        },
        sounds = {
            [[bandit\fight\attack\attack_3]],
            [[bandit\fight\attack\attack_4]]
        }
    },

    [ "l03_agroprom" ] = {
        creatures = {
            "agr_soldier_regular",
            "agr_soldier_veteran",
            "agr_bandit_respawn_1",
            "agr_bandit_respawn_2"
        },
        sounds = {
            [[military\fight\attack\attack_1]],
            [[military\fight\attack\attack_2]],
            [[bandit\fight\attack\attack_5]],
            [[bandit\fight\attack\attack_6]]
        }
    },

    [ "l03u_agr_underground"] = {
        creatures = {
            "agr_soldier_regular",
            "agr_soldier_veteran",
            "agr_bandit_respawn_1",
            "agr_bandit_respawn_2"
        },
        sounds = {
            [[military\fight\attack\attack_one_1]],
            [[military\fight\attack\attack_one_2]],
            [[bandit\fight\attack\attack_7]],
            [[bandit\fight\attack\attack_8]]
        }
    },

    [ "l04_darkvalley"] = {
        creatures = {
            "val_bandit_respawn_1",
            "val_bandit_respawn_2",
            "val_bandit_respawn_3",
            "val_soldier_respawn_1"
        },
        sounds = {
            [[bandit\fight\attack\attack_9]],
            [[bandit\fight\attack\attack_8]],
            [[bandit\fight\attack\attack_1]],
            [[military\fight\attack\attack_one_3]]
        }
    },

    [ "l06_rostok" ] = {
        creatures = {
            "ros_killer_respawn_1",
            "ros_killer_respawn_2",
            "ros_killer_respawn_3",
            "ros_bandit_respawn_3"
        },
        sounds = {
            [[killer\fight\attack\attack_3]],
            [[killer\fight\attack\attack_4]],
            [[killer\fight\attack\attack_5]],
            [[bandit\fight\attack\attack_2]]
        }
    },

    [ "l07_military" ] = {
        creatures = {
            "mil_killer_respawn_1",
            "mil_killer_respawn_2",
            "mil_killer_respawn_3"
        },
        sounds = {
            [[killer\fight\attack\attack_5]],
            [[killer\fight\attack\attack_6]],
            [[killer\fight\attack\attack_7]]
        }
    },

    [ "l08_yantar" ] = {
        creatures = {
            "yan_zombied_respawn_1",
            "yan_zombied_respawn_2",
            "yan_zombied_respawn_3"
        },
        sounds = {
            [[zombied\fight\attack\attack_4]],
            [[zombied\fight\attack\attack_5]],
            [[zombied\fight\attack\attack_6]]
        }
    },

    [ "l10_radar" ] = {
        creatures = {
            "rad_monolith_respawn_1",
            "rad_monolith_respawn_2",
            "rad_monolith_respawn_3",
            "rad_specnaz_respawn_specnaz",
            "rad_soldier_master",
            "rad_zombied_respawn_1",
            "rad_zombied_respawn_2",
            "rad_zombied_respawn_3"
        },
        sounds = {
            [[monolith\fight\attack\attack_one_1]],
            [[monolith\fight\attack\attack_one_2]],
            [[monolith\fight\attack\attack_one_3]],
            [[military\fight\attack\attack_one_4]],
            [[military\fight\attack\attack_one_5]],
            [[zombied\fight\attack\attack_8]],
            [[zombied\fight\attack\attack_4]],
            [[zombied\fight\attack\attack_6]]
        }
    },

    [ "l11_pripyat" ] = {
        creatures = {
            "pri_monolith_respawn_1",
            "pri_monolith_respawn_2",
            "pri_monolith_respawn_3"
        },
        sounds = {
            [[monolith\fight\attack\attack_one_4]],
            [[monolith\fight\attack\attack_one_5]],
            [[monolith\fight\attack\attack_one_1]]
        }
    }
}

function empty_treasure( box_id )
    --check if there is no any stalker too close
    local habarcost = get_item_box_cost( box_id )
    if habarcost < 1000 then return end
    local prob = 100
    if     habarcost < 3000  then prob = 5
    elseif habarcost < 5000  then prob = 10
    elseif habarcost < 10000 then prob = 15
    elseif habarcost < 20000 then prob = 20
    elseif habarcost < 35000 then prob = 25
    end
    if my_lua_random(100) > prob then return end
    --ODS("[~T]. #DBG: 64K enum 8")
    for iter = 1, MAX_OBJ_ID do
        local obj = g_sim:object( iter )
        if
            obj and IsStalker( obj )
            and obj.health and obj:health() > 0
            and not sobj_is_far( obj, 80 )
            and obj:community() ~= "monolith"
            and obj:community() ~= "military"
            and obj:community() ~= "killer"
            and obj:community() ~= "bandit"
            and obj:community() ~= "zombied"
        then
            return
        end
    end
    local lname = level.name()
    if not spawn_maps[ lname ] then return end
    local st = my_lua_random( #spawn_maps[ lname ].creatures )
    if st <= 0 then return end
    local pos
    local angles = { 150, 210 }
    for iter, angl in pairs( angles ) do
        --spawn a creature behind the actor
        local radius = 40--3
        local dir    = vector_rotate_y( db.actor:direction(), angl )
        local lv     = level.vertex_in_direction( db.actor:level_vertex_id(), dir, radius )
        if not lv or lv == BAD_OBJ_ID then
            lv  = db.actor:level_vertex_id()
            pos = db.actor:position():add( vector():set( dir.x * radius, 0, dir.z * radius ) )
        else
            pos = level.vertex_position( lv )
        end
        g_sim:create(
            spawn_maps[ lname ].creatures[ st ], pos, lv, db.actor:game_vertex_id()
        )
    end
    local sname = spawn_maps[ lname ].sounds[ st ]
    if pos and sname and sanem ~= "" then
        local snd_obj = xr_sound.get_safe_sound_object( [[characters_voice\human_01\]] .. sname )
        snd_obj:play_at_pos( db.actor, pos )
        local active_item = db.actor:active_item()
        if
            active_item
            and active_item:section() ~= "bolt"
            and active_item:section() ~= "wpn_knife"
        then
            db.actor:drop_item( active_item )
        end
    end
end

function checked_marked_npc()
    if loaded then return end
    local metkas   = {}
    local stalkers = {}
    --ODS("[~T]. #DBG: 64K enum 9")
    for iobj = 1, MAX_OBJ_ID do
        local obj = g_sim:object( iobj )
        if obj then 
            if
                IsStalker( obj )
                and level.map_has_object_spot( obj.id, "red_location" ) ~= 0
            then
                table.insert( stalkers, obj )
            elseif
                obj:section_name() == "amk_metka"
                and ( not obj.parent_id or obj.parent_id == BAD_OBJ_ID )
            then
                table.insert( metkas, obj )
            end         
        end
    end
    for inpc = 1, #stalkers do
        local npc = stalkers[ inpc ]
        --find closest gps metka
        dist = 1000000.0
        if game_graph():valid_vertex_id( npc.m_game_vertex_id ) then
            local nlid   = game_graph():vertex( npc.m_game_vertex_id ):level_id()
            local nmetka = nil
            for imtk = 1, #metkas do
                local metka = metkas[ imtk ]
                if game_graph():valid_vertex_id( metka.m_game_vertex_id ) then
                    local mlid = game_graph():vertex( metka.m_game_vertex_id ):level_id()
                    if
                        nlid == mlid
                        and npc.position:distance_to( metka.position ) < dist
                    then
                        dist   = npc.position:distance_to( metka.position )
                        nmetka = metka
                    end
                end
            end
            if nmetka then
                set_metka_victim( nmetka.id, npc.id )
            end
        end
    end
end

function get_be_enemy( npc_id )
    if be_enemies[ npc_id ] then
        return be_enemies[ npc_id ]
    else
        return 0
    end
end

function set_be_enemy_f( npc_id, lvl )
    if not npc_id or npc_id == BAD_OBJ_ID then return end
    local obj = g_sim:object( npc_id ) 
    if obj and IsStalker( obj ) and obj.health and obj:health() > 0 then
        be_enemies[ npc_id ] = lvl
    end
end

function set_be_enemy( npc_id, lvl )
    if
        not npc_id or npc_id == BAD_OBJ_ID
        or ( be_enemies[ npc_id ] and be_enemies[ npc_id ] >= lvl )
    then
        return
    end
    local obj = g_sim:object( npc_id ) 
    if obj and IsStalker( obj ) and obj.health and obj:health() > 0 then
        if obj.m_story_id ~= nil and obj.m_story_id < NONE_SID and lvl > enemy_level_hit then
            be_enemies[ npc_id ] = enemy_level_hit
        else
            be_enemies[ npc_id ] = lvl
        end
    end
end

function clear_be_enemy( npc_id )
    if be_enemies[ npc_id ] then be_enemies[ npc_id ] = nil end
end

function do_add_abuse( npc_id )
    if db.storage[ npc_id ] then
        local t = db.storage[ npc_id ].abuse
        if t and t.abuse_manager then
            t.abuse_manager.abuse_value = t.abuse_manager.abuse_value + t.abuse_manager.abuse_rate * 100
        end
    end
end

local angry_npc_timer = {}
--[[function load_angry_npc_timer()
 angry_npc_timer = nlc_vars.angr_npc_tmr,{}
 nlc_vars.angr_npc_tmr = nil
end
function save_angry_npc_timer()
 nlc_vars.angr_npc_tmr = angry_npc_timer
end--]]
function check_be_enemy()
    for iter, lvl in pairs( be_enemies ) do
        local obj = g_sim:object( iter )
        if
            obj and obj.online
            and IsStalker( obj ) and obj.health and obj:health() > 0
        then
            local npc = client_obj( obj.id )
            if npc then
                --ODS("[~T]. #DBG: непись сердится ~C0A"..npc:name().." time  "..time_global().."~C07")
                if lvl == enemy_level_angry then
                    if angry_npc_timer[ iter ] then
                        if time_global() >= angry_npc_timer[ iter ] then
                            angry_npc_timer[ iter ] = nil
                            npc:set_relation( game_object.neutral, db.actor )
                            local rel = npc:relation( db.actor )
                            if rel and rel ~= game_object.enemy then
                                set_be_enemy_f( iter, enemy_level_hit )
                            end
                        end
                    else
                        angry_npc_timer[ iter ] = time_global() + be_enemy_time
                    end
                else
                    local rel = npc:relation( db.actor )
                    if rel and rel == game_object.enemy then
                        -- an enemy NPC cannot punch Mecheniy
                        clear_be_enemy( iter )
                    end
                end
            end
        end
    end
end

function check_be_enemies()
    for npc_id, lvl in pairs( be_enemies ) do
        local obj = g_sim:object( npc_id )
        if not
            (
                obj and IsStalker( obj )
                and obj.alive and obj:alive()
                and obj.health and obj:health() > 0
            )
        then
            clear_be_enemy( npc_id )
        end
    end
end

function check_trapped_bodies()
    for npc_id, tr in pairs( trapped_bodies ) do
        local obj = g_sim:object( npc_id )
        if not
            (
                obj and IsStalker( obj )
                and obj.alive and not obj:alive()
                and obj.health and obj:health() <= 0
            )
        then
            clear_body_trap( npc_id )
        end
    end
end

function get_npc_name( obj )
    local m_s_name = ""
    if obj then
        if news_main.isGameObject( obj ) then
            if obj.character_name then m_s_name = obj:character_name() end
        else
            local ob = news_main.get_obj( obj.id )
            if ob and ob.character_name then
                m_s_name = ob:character_name()
            else
                local pk   = get_netpk( obj )
                local data = pk:get()
                if data and data.checked_characters then
                    m_s_name = data.checked_characters
                end
            end
        end
    end
    if m_s_name == nil then m_s_name = "" end
    return m_s_name
end

function test_event() end
